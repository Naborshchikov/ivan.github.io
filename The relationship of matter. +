{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [],
   "source": [
    "\"\"\"The relationship of matter. +\"\"\" \n",
    "# Program ver 5.1\n",
    "import pandas as pd\n",
    "import numpy as np\n",
    "from numpy import *\n",
    "from mpl_toolkits.mplot3d import Axes3D \n",
    "from matplotlib.pyplot import *\n",
    "import matplotlib as mpl\n",
    "import matplotlib.pyplot as plt\n",
    "from scipy.optimize import curve_fit\n",
    "from scipy.interpolate import PchipInterpolator\n",
    "from scipy.signal import savgol_filter\n",
    "from prettytable import PrettyTable\n",
    "from collections import namedtuple\n",
    "import pandas_profiling\n",
    "import cufflinks as cf\n",
    "import plotly.offline\n",
    "\n",
    "# Uncomment the line below if you plan to view 3D graphics from different angles.\n",
    "# %matplotlib notebook\n",
    "\n",
    "# Error elimination, since it does not affect the values obtained\n",
    "# The graph is rendered in 3D, the package for this type of charts uses the square root\n",
    "# The presence of a pair of negative numbers excludes their visualization\n",
    "import warnings\n",
    "warnings.filterwarnings(\"ignore\", category=RuntimeWarning) \n",
    "\n",
    "Initial_conditions = [[1, 'Project implemented in Python', 'ver. 3.7.6 \\n'],\n",
    "                      [2, 'ID - Anaconda', 'ver. 2020 02 \\n'],\n",
    "                      [3, 'All data presented in the SI system', 'nist.gov/\\n'],\n",
    "                      [4, 'All constants are taken from the\\n'\n",
    "                       'data the US NIST.\\n', 'nist.gov/ \\n'],\n",
    "                      [5, 'Particle structure -\\n'                       \n",
    "                       'published works of Nobel laureates.\\n', \n",
    "                       'published scientific works \\n'],\n",
    "                      [6, 'Protons, neutrons\\n'\n",
    "                       'have a core and two shells.\\n', 'Robert Hofstadter \\n'],\n",
    "                      [7, 'Speed of light in a vacuum, c = 299792458\\n', 'nist.gov/ \\n'],\n",
    "                      [8, 'Electrical constant, ε0 = 8.8541878128E−12\\n', 'nist.gov/ \\n'],\n",
    "                      [9, 'Gravitational constant, G = 6.67430E-11\\n', 'nist.gov/ \\n'],\n",
    "                      [10, 'Electric charge of an electron\\n'\n",
    "                       '-1.602176634e-19 \\n', 'nist.gov/ \\n'],\n",
    "                      [11, 'π = 3.14159265358979', \"Scientific American\\n\"],\n",
    "                      [12, \"Planck's constant, h = 6.62607015E−34\", 'nist.gov/\\n'],\n",
    "                      [13, 'Electron diameter 10e−22,\\n', \n",
    "                       'Hans D. Dehmelt Experiments\\n'],\n",
    "                      [14, 'The proton consists of two quarks \\n', \n",
    "                       'Murray Gell-Mann\\n'],\n",
    "                      [15, 'The newneutron consists of two quarks \\n', \n",
    "                       'Murray Gell-Mann \\n'],\n",
    "                      [16, 'Quark radius − (0.47 · 10E−16 cm)E2\\n'\n",
    "                       '< RE2 < (0.43 · 10E−16 cm)E2 \\n', \n",
    "                       'arxiv.org/pdf/1604.01280.pdf \\n'],\n",
    "                      [17, 'Additional information\\n', \n",
    "                       'Data from available sources. \\n'],\n",
    "                     [18, \"Quark condensate provides about 9\\n\"\n",
    "                      \"percent of the proton's mass\\n\",\n",
    "                     'Physical Review Letters, 2018\\n,'\n",
    "                      ' website arXiv.org\\n'],\n",
    "                     [19, 'Electron diameter: 10e−22 \\n', \n",
    "                      'Nobel lecture, December, 8, 1989,\\n'\n",
    "                      ' Hans D. Dehmelt Experiments with \\n'\n",
    "                      'an isolated subatomic particle at rest\\n'],\n",
    "                     [20, 'proton mass: 1.67262192369E-27\\n', \n",
    "                      'nist.gov/\\n'],\n",
    "                     [21, 'neutron mass: 1.67492749804E-27\\n',\n",
    "                      'nist.gov/\\n'],\n",
    "                     [22, 'The magnitude of the charge\\n'\n",
    "                      'of the core, shells in the proton\\n'\n",
    "                     'respectively: 0.35; 0.5; 0.15\\n', \n",
    "                      'Robert Hofstadter the\\n'\n",
    "                      'Nobel laureate\\n'], \n",
    "                     [23, 'The magnitude of the charge of the core,\\n'\n",
    "                      ' shells in the neutron\\n'\n",
    "                     'respectively: 0.35; - 0.5; 0.15\\n', \n",
    "                      'Robert Hofstadter the\\n'],\n",
    "                     [24, 'The proton radius: 0.84 fm\\n', \n",
    "                      'aps.org/publications/apsnews/201806/proton.cfm\\n'],\n",
    "                     [25, 'The neutron radius: 0.8e−15\\n', \n",
    "                      'Povh, B.; Rith, K.(2002).\\n'],\n",
    "                     [26, 'Rradius of the proton core: 0.23 ± 0.03 F\\n', \n",
    "                      'https://doi.org/10.1103/PhysRevD.18.2484\\n'],\n",
    "                     [27, 'Rradius of the neutron core:\\n'\n",
    "                      ' from 0.3 to 0.36 fm\\n', \n",
    "                      'arxiv.org/pdf/1810.00486.pdf\\n'],\n",
    "                     [28, 'The radius of the inner shell of the neutron\\n'\n",
    "                      'is approximately 0.6 fm.\\n', \n",
    "                      'actaphys.uj.edu.pl/fulltext?series=Reg&vol=30&page=119\\n']] \n",
    "\n",
    "table1 = PrettyTable(['#', 'Description', 'Link to source/ comments'])\n",
    "\n",
    "for rec in Initial_conditions:\n",
    "    table1.add_row(rec)\n",
    "\n",
    "# Proton, neutron consist of a nucleus and two shells, or three quarks.\n",
    "# Therefore, quarks must consist of a nucleus and shells.\n",
    "# A quark can have several shells, like layers of air near the Earth.\n",
    "# This calculation is limited to two shells.\n",
    "# Further study of quarks by scientists will possibly increase the number\n",
    "# shells for the calculation, make it more accurate.\n",
    "\n",
    "class Algorithm():\n",
    "# Assigning values to constants.\n",
    "# Constants with more characters than constants according to US NIST data are index two.\n",
    "\n",
    "    constantε0 = 8.8541878128e-12\n",
    "    constantε02 = 8.85418781762039e-12\n",
    "    \n",
    "    constantc = 299792458\n",
    "        \n",
    "    constantg = 6.67430E-11\n",
    "    constantg2 = 6.67448478E-11\n",
    "    \n",
    "    constanth = 6.62607015e-34\n",
    "    \n",
    "    \n",
    "# Assigning values to data that has become common knowledge.\n",
    "# Data from different research groups may differ from each other.\n",
    "\n",
    "    π = 3.14159265358979\n",
    "    \n",
    "# electron mass\n",
    "    me = 9.1093837015e-31\n",
    "    \n",
    "# electron diameter\n",
    "    de = 10e-22\n",
    "    \n",
    "# Electric charge of an electron\n",
    "    qe = 1.602176634e-19\n",
    "    qe2 = 1.602176620898e-19\n",
    "    \n",
    "# proton mass  \n",
    "    mp = 1.67262192369E-27\n",
    "# radius of a proton estimated by electric charge\n",
    "    rp = 0.84e-15\n",
    "# Rradius of the proton core\n",
    "    rpc = 0.23e-15\n",
    "# The radius of the inner layer (assumption).\n",
    "    rpi = 0.6e-15 \n",
    "# neutron mass\n",
    "    mn = 1.67492749804E-27\n",
    "# radius of a neutron\n",
    "    rn = 0.8e-15\n",
    "# Rradius of the neutron core, \n",
    "# following from the hadronic and nuclear matter properties\n",
    "    rnc = 0.33e-15\n",
    "# The radius of the inner layer.\n",
    "    rni = 0.6e-15\n",
    "    \n",
    "# quark radius\n",
    "# The third sign \"n\" - for negative radius\n",
    "# The third sign \"p\" - for positive radius\n",
    "    qrn = - 0.47 * 10e-18\n",
    "    qrp = 0.43 * 10e-18\n",
    "    \n",
    "# The magnitude of the charge of the core, shells respectively\n",
    "\n",
    "# proton\n",
    "    SHELLP0 = 0.35\n",
    "    SHELLP1 = 0.5\n",
    "    SHELLP2 = 0.15\n",
    "    \n",
    "# neutron\n",
    "    SHELLN0 = 0.35\n",
    "    SHELLN1 = -0.5\n",
    "    SHELLN2 = 0.15\n",
    "    \n",
    "    def __init__ (self, xq02, xq13, xv02, xv13, xm02, xm13):\n",
    "        \n",
    "        \n",
    "# The first symbol is the name of the quark, the second symbol is:\n",
    "# 0 - core, 1 - inner shell, 2 - outer shell.\n",
    "\n",
    "# Rule 1:\n",
    "# The calculation takes into account that the quarks of the nucleus\n",
    "# can not fall on a single line, as it will mean the synthesis of quarks\n",
    "# and the loss of their identity.\n",
    "\n",
    "# Rule 2:\n",
    "# Quarks are connected if there is their intersection is at least one shell.\n",
    "\n",
    "# Rule 3:\n",
    "# The combination of quarks is obliged to provide the most dense arrangement.\n",
    "\n",
    "        self.xq02 = xq02\n",
    "        self.xq13 = xq13\n",
    "                \n",
    "        self.xv02 = xv02\n",
    "        self.xv13 = xv13\n",
    "                \n",
    "        self.xm02 = xm02\n",
    "        self.xm13 = xm13\n",
    "                \n",
    "# The combination of \"u\" and \"d\" quarks makes it possible to obtain several \n",
    "# variants of matrices for the proton, neutron.\n",
    "\n",
    "# The matrixes for the proton.\n",
    "a000 = ['u0', 0,   0,   0,  0]\n",
    "a001 = [ 0,  'u1', 0,   0,  0]\n",
    "a002 = [ 0,   0,  'u2', 0,  0]\n",
    "\n",
    "a003 = [0, 'u0',  0,   0,   0]\n",
    "a004 = [0,  0,   'u1', 0,   0]\n",
    "a005 = [0,  0,    0,  'u2', 0]\n",
    "\n",
    "a006 = [0,  0, 'd0', 0,    0]\n",
    "a007 = [0,  0,  0,  'd1',  0]\n",
    "a008 = [0,  0,  0,   0,   'd2']\n",
    "\n",
    "#a0 = list(zip(a000, a001, a002, a003, a004, a005, a006, a007, a008))\n",
    "\n",
    "\"\"\"The result is a matrix.\n",
    "a0 = [('u0', 0,   0,   0,   0,   0,   0,   0,   0), \n",
    "      (0,   'u1', 0,  'u0', 0,   0,   0,   0,   0), \n",
    "      (0,    0,  'u2', 0,  'u1', 0,  'd0', 0,   0),\n",
    "      (0,    0,   0,   0,   0,  'u2', 0,  'd1', 0), \n",
    "      (0,    0,   0,   0,   0,   0,   0,   0,  'd2')]\"\"\"\n",
    "\n",
    "      \n",
    "# The matrixes for the neutron.\n",
    "a020 = ['d0', 0,   0,   0,   0]\n",
    "a021 = [ 0,  'd1', 0,   0,   0]\n",
    "a022 = [ 0,   0,  'd2', 0,   0]\n",
    "\n",
    "a023 = [0, 'd0',  0,   0,   0]\n",
    "a024 = [0,  0,   'd1', 0,   0]\n",
    "a025 = [0,  0,    0,  'd2', 0]\n",
    "\n",
    "a026 = [0,  0, 'u0', 0,   0]\n",
    "a027 = [0,  0,  0,  'u1', 0]\n",
    "a028 = [0,  0,  0,   0,  'u2']\n",
    "\n",
    "#a2 = list(zip(a020, a021, a022, a023, a024, a025, a026, a027, a028))\n",
    "\n",
    "\"\"\"The result is a matrix.\n",
    "a2 = [['d0',  0,  0,   0,   0,   0,   0,   0,   0], \n",
    "      [0,   'd1', 0,  'd0', 0,   0,   0,   0,   0], \n",
    "      [0,    0,  'd2', 0,  'd1', 0,  'u0', 0,   0],\n",
    "      [0,    0,   0,   0,   0,  'd2', 0,  'u1', 0], \n",
    "      [0,    0,   0,   0,   0,   0,   0,   0,  'u2']]\"\"\"\n",
    "\n",
    "# Since we know the values for the nuclei and shells of the proton, neutron, \n",
    "# for the calculation we use the matrices a0 with a2.\n",
    "\n",
    "\"\"\"It looks visually.\n",
    "[['u0' '0' '0' '0' '0' '0' '0' '0' '0']\n",
    " ['0' 'u1' '0' 'u0' '0' '0' '0' '0' '0']\n",
    " ['0' '0' 'u2' '0' 'u1' '0' 'd0' '0' '0']\n",
    " ['0' '0' '0' '0' '0' 'u2' '0' 'd1' '0']\n",
    " ['0' '0' '0' '0' '0' '0' '0' '0' 'd2']]\n",
    "[['d0' '0' '0' '0' '0' '0' '0' '0' '0']\n",
    " ['0' 'd1' '0' 'd0' '0' '0' '0' '0' '0']\n",
    " ['0' '0' 'd2' '0' 'd1' '0' 'u0' '0' '0']\n",
    " ['0' '0' '0' '0' '0' 'd2' '0' 'u1' '0']\n",
    " ['0' '0' '0' '0' '0' '0' '0' '0' 'u2']]\"\"\"\n",
    "\n",
    "# All lines with 0 in the second character form a core.\n",
    "# The remaining two lines form the inner and outer shell.\n",
    "\n",
    "# Matrices are converted into an array, taking into account the available\n",
    "# data for the calculation. \n",
    "# The array represents the equations for the proton and neutron.\n",
    "      \n",
    "# The top three lines of the array are proton (coefficients for the array)\n",
    "# (u0+u0 = 2; u1+u1 = 2; u2 = 1; d0 = 1) - core for a0; (d1 = 1; u2 = 1) - \n",
    "# inner shell for a0; d2 = 1 - outer shell for a0\n",
    "\n",
    "# The bottom three lines of the array are a neutron (coefficients for the array)\n",
    "# (d0+d0 = 2; d1+d1 = 2; d2 = 1; u0 = 1) - core for a2; (d2 = 1; u1 = 1) - \n",
    "# inner shell for a2; u2 = 1 - outer shell for a2\n",
    "\n",
    "x00 = (a000.count('u0') + a001.count('u0') + a002.count('u0') +\n",
    "       a003.count('u0') + a004.count('u0') + a006.count('u0')) \n",
    "\n",
    "x01 = (a000.count('u1') + a001.count('u1') + a002.count('u1') +\n",
    "       a003.count('u1') + a004.count('u1') + a006.count('u1'))\n",
    "\n",
    "x02 = (a000.count('u2') + a001.count('u2') + a002.count('u2') +\n",
    "       a003.count('u2') + a004.count('u2') + a006.count('u2'))\n",
    "\n",
    "x03 = (a000.count('d0') + a001.count('d0') + a002.count('d0') +\n",
    "       a003.count('d0') + a004.count('d0') + a006.count('d0'))\n",
    "\n",
    "x04 = (a000.count('d1') + a001.count('d1') + a002.count('d1') +\n",
    "       a003.count('d1') + a004.count('d1') + a006.count('d1'))\n",
    "\n",
    "x05 = (a000.count('d2') + a001.count('d2') + a002.count('d2') +\n",
    "       a003.count('d2') + a004.count('d2') + a006.count('d2'))\n",
    "\n",
    "an20 = [0]\n",
    "an20.insert(0, x00)\n",
    "an20.insert(1, x01)\n",
    "an20.insert(2, x02)\n",
    "an20.insert(3, x03)\n",
    "an20.insert(4, x04)\n",
    "an20.insert(5, x05)\n",
    "an20.pop(6)\n",
    "\n",
    "x10 = (a005.count('u0') + a007.count('u0')) \n",
    "x11 = (a005.count('u1') + a007.count('u1'))\n",
    "x12 = (a005.count('u2') + a007.count('u2'))\n",
    "x13 = (a005.count('d0') + a007.count('d0'))\n",
    "x14 = (a005.count('d1') + a007.count('d1'))\n",
    "x15 = (a005.count('d2') + a007.count('d2'))\n",
    "\n",
    "an21 = [0]\n",
    "an21.insert(0, x10)\n",
    "an21.insert(1, x11)\n",
    "an21.insert(2, x12)\n",
    "an21.insert(3, x13)\n",
    "an21.insert(4, x14)\n",
    "an21.insert(5, x15)\n",
    "an21.pop(6)\n",
    "\n",
    "x20 = a008.count('u0') \n",
    "x21 = a008.count('u1')\n",
    "x22 = a008.count('u2')\n",
    "x23 = a008.count('d0')\n",
    "x24 = a008.count('d1')\n",
    "x25 = a008.count('d2')\n",
    "\n",
    "an22 = [0]\n",
    "an22.insert(0, x20)\n",
    "an22.insert(1, x21)\n",
    "an22.insert(2, x22)\n",
    "an22.insert(3, x23)\n",
    "an22.insert(4, x24)\n",
    "an22.insert(5, x25)\n",
    "an22.pop(6)\n",
    "\n",
    "x30 = (a020.count('u0') + a021.count('u0') + a022.count('u0') +\n",
    "       a023.count('u0') + a024.count('u0') + a026.count('u0')) \n",
    "\n",
    "x31 = (a020.count('u1') + a021.count('u1') + a022.count('u1') +\n",
    "       a023.count('u1') + a024.count('u1') + a026.count('u1'))\n",
    "\n",
    "x32 = (a020.count('u2') + a021.count('u2') + a022.count('u2') +\n",
    "       a023.count('u2') + a024.count('u2') + a026.count('u2'))\n",
    "\n",
    "x33 = (a020.count('d0') + a021.count('d0') + a022.count('d0') +\n",
    "       a023.count('d0') + a024.count('d0') + a026.count('d0'))\n",
    "\n",
    "x34 = (a020.count('d1') + a021.count('d1') + a022.count('d1') +\n",
    "       a023.count('d1') + a024.count('d1') + a026.count('d1'))\n",
    "\n",
    "x35 = (a020.count('d2') + a021.count('d2') + a022.count('d2') +\n",
    "       a023.count('d2') + a024.count('d2') + a026.count('d2'))\n",
    "\n",
    "a120 = [0]\n",
    "a120.insert(0, x30)\n",
    "a120.insert(1, x31)\n",
    "a120.insert(2, x32)\n",
    "a120.insert(3, x33)\n",
    "a120.insert(4, x34)\n",
    "a120.insert(5, x35)\n",
    "a120.pop(6)\n",
    "\n",
    "x40 = (a025.count('u0') + a027.count('u0')) \n",
    "x41 = (a025.count('u1') + a027.count('u1'))\n",
    "x42 = (a025.count('u2') + a027.count('u2'))\n",
    "x43 = (a025.count('d0') + a027.count('d0'))\n",
    "x44 = (a025.count('d1') + a027.count('d1'))\n",
    "x45 = (a025.count('d2') + a027.count('d2'))\n",
    "\n",
    "a121 = [0]\n",
    "a121.insert(0, x40)\n",
    "a121.insert(1, x41)\n",
    "a121.insert(2, x42)\n",
    "a121.insert(3, x43)\n",
    "a121.insert(4, x44)\n",
    "a121.insert(5, x45)\n",
    "a121.pop(6)\n",
    "\n",
    "x50 = a028.count('u0') \n",
    "x51 = a028.count('u1')\n",
    "x52 = a028.count('u2')\n",
    "x53 = a028.count('d0')\n",
    "x54 = a028.count('d1')\n",
    "x55 = a028.count('d2')\n",
    "\n",
    "a122 = [0]\n",
    "a122.insert(0, x50)\n",
    "a122.insert(1, x51)\n",
    "a122.insert(2, x52)\n",
    "a122.insert(3, x53)\n",
    "a122.insert(4, x54)\n",
    "a122.insert(5, x55)\n",
    "a122.pop(6)\n",
    "\n",
    "a02 = [an20, an21, an22, a120, a121, a122]\n",
    "a02 = array(a02)\n",
    "\n",
    "\"\"\"It looks visually.\n",
    "a02 = array([[2.0 , 2.0, 1.0, 1.0, 0.0, 0.0],\n",
    "             [0.0, 0.0, 1.0, 0.0, 1.0, 0.0], \n",
    "             [0.0, 0.0, 0.0, 0.0, 0.0, 1.0], \n",
    "             [1.0, 0.0, 0.0, 2.0, 2.0, 1.0], \n",
    "             [0.0, 1.0, 0.0, 0.0, 0.0, 1.0], \n",
    "             [0.0, 0.0, 1.0, 0.0, 0.0, 0.0]])\"\"\"\n",
    "\n",
    "a010 = ['u0', 0,   0,   0,   0]\n",
    "a011 = [ 0,  'u1', 0,   0,   0]\n",
    "a012 = [ 0,   0,  'u2', 0,   0]\n",
    "\n",
    "a013 = [0, 'd0',  0,   0,   0]\n",
    "a014 = [0,  0,   'd1', 0,   0]\n",
    "a015 = [0,  0,    0,  'd2', 0]\n",
    "\n",
    "a016 = [0,  0, 'u0', 0,   0]\n",
    "a017 = [0,  0,  0,  'u1', 0]\n",
    "a018 = [0,  0,  0,   0,  'u2']\n",
    "\n",
    "#a1 = list(zip(a010, a011, a012, a013, a014, a015, a016, a017, a018))\n",
    "\n",
    "\"\"\"The result is a matrix.\n",
    "a1 = [('u0',  0,  0,   0,   0,   0,   0,   0,   0), \n",
    "      (0,   'u1', 0,  'd0', 0,   0,   0,   0,   0), \n",
    "      (0,    0,  'u2', 0,  'd1', 0,  'u0', 0,   0),\n",
    "      (0,    0,   0,   0,   0,  'd2', 0,  'u1', 0), \n",
    "      (0,    0,   0,   0,   0,   0,   0,   0,  'u2')]\"\"\"\n",
    "\n",
    "a030 = ['d0', 0,   0,   0,   0]\n",
    "a031 = [ 0,  'd1', 0,   0,   0]\n",
    "a032 = [ 0,   0,  'd2', 0,   0]\n",
    "\n",
    "a033 = [0, 'u0',  0,   0,   0]\n",
    "a034 = [0,  0,   'u1', 0,   0]\n",
    "a035 = [0,  0,    0,  'u2', 0]\n",
    "\n",
    "a036 = [0,  0, 'd0', 0,   0]\n",
    "a037 = [0,  0,  0,  'd1', 0]\n",
    "a038 = [0,  0,  0,   0,  'd2']\n",
    "\n",
    "#a3 = list(zip(a030, a031, a032, a033, a034, a035, a036, a037, a038))\n",
    "\n",
    "\"\"\"The result is a matrix.\n",
    "a3 = [('d0', 0,   0,   0,   0,   0,   0,   0,   0), \n",
    "      (0,   'd1', 0,  'u0', 0,   0,   0,   0,   0), \n",
    "      (0,    0,  'd2', 0,  'u1', 0,  'd0', 0,   0),\n",
    "      (0,    0,   0,   0,   0,  'u2', 0,  'd1', 0), \n",
    "      (0,    0,   0,   0,   0,   0,   0,   0,  'd2')]\"\"\"\n",
    "\n",
    "# Since we know the values for the nuclei and shells of the proton, neutron, \n",
    "# for the calculation we use the matrices a1 with a3.\n",
    "\"\"\"It looks visually.\n",
    "[['u0' '0' '0' '0' '0' '0' '0' '0' '0']\n",
    " ['0' 'u1' '0' 'd0' '0' '0' '0' '0' '0']\n",
    " ['0' '0' 'u2' '0' 'd1' '0' 'u0' '0' '0']\n",
    " ['0' '0' '0' '0' '0' 'd2' '0' 'u1' '0']\n",
    " ['0' '0' '0' '0' '0' '0' '0' '0' 'u2']]\n",
    "[['d0' '0' '0' '0' '0' '0' '0' '0' '0']\n",
    " ['0' 'd1' '0' 'd0' '0' '0' '0' '0' '0']\n",
    " ['0' '0' 'd2' '0' 'd1' '0' 'u0' '0' '0']\n",
    " ['0' '0' '0' '0' '0' 'd2' '0' 'u1' '0']\n",
    " ['0' '0' '0' '0' '0' '0' '0' '0' 'u2']]\"\"\"\n",
    "\n",
    "# The top three lines of the array are a proton (coefficients for the array)\n",
    "# (u0+u0 = 2; u1 = 1; u2 = 1; d0 = 1; d1 = 1) - core for a1; (d2 = 1; u1 = 1) - \n",
    "# inner shell for a1; u2 = 1 - outer shell for a1\n",
    "\n",
    "# The bottom three lines of the array are neutron (coefficients for the array)\n",
    "# (d0+d0 = 2; d1 = 1; d2 = 1; u0 = 1; u1 = 1) - core for a3; (u2 = 1; d1 = 1) - \n",
    "# inner shell for a3; d2 = 1 - outer shell for a3\n",
    "\n",
    "x60 = (a010.count('u0') + a011.count('u0') + a012.count('u0') +\n",
    "       a013.count('u0') + a014.count('u0') + a016.count('u0')) \n",
    "\n",
    "x61 = (a010.count('u1') + a011.count('u1') + a012.count('u1') +\n",
    "       a013.count('u1') + a014.count('u1') + a016.count('u1'))\n",
    "\n",
    "x62 = (a010.count('u2') + a011.count('u2') + a012.count('u2') +\n",
    "       a013.count('u2') + a014.count('u2') + a016.count('u2'))\n",
    "\n",
    "x63 = (a010.count('d0') + a011.count('d0') + a012.count('d0') +\n",
    "       a013.count('d0') + a014.count('d0') + a016.count('d0'))\n",
    "\n",
    "x64 = (a010.count('d1') + a011.count('d1') + a012.count('d1') +\n",
    "       a013.count('d1') + a014.count('d1') + a016.count('d1'))\n",
    "\n",
    "x65 = (a010.count('d2') + a011.count('d2') + a012.count('d2') +\n",
    "       a013.count('d2') + a014.count('d2') + a016.count('d2'))\n",
    "\n",
    "a123 = [0]\n",
    "a123.insert(0, x60)\n",
    "a123.insert(1, x61)\n",
    "a123.insert(2, x62)\n",
    "a123.insert(3, x63)\n",
    "a123.insert(4, x64)\n",
    "a123.insert(5, x65)\n",
    "a123.pop(6)\n",
    "\n",
    "x70 = (a015.count('u0') + a017.count('u0')) \n",
    "x71 = (a015.count('u1') + a017.count('u1'))\n",
    "x72 = (a015.count('u2') + a017.count('u2'))\n",
    "x73 = (a015.count('d0') + a017.count('d0'))\n",
    "x74 = (a015.count('d1') + a017.count('d1'))\n",
    "x75 = (a015.count('d2') + a017.count('d2'))\n",
    "\n",
    "a124 = [0]\n",
    "a124.insert(0, x70)\n",
    "a124.insert(1, x71)\n",
    "a124.insert(2, x72)\n",
    "a124.insert(3, x73)\n",
    "a124.insert(4, x74)\n",
    "a124.insert(5, x75)\n",
    "a124.pop(6)\n",
    "\n",
    "\n",
    "x80 = a018.count('u0') \n",
    "x81 = a018.count('u1')\n",
    "x82 = a018.count('u2')\n",
    "x83 = a018.count('d0')\n",
    "x84 = a018.count('d1')\n",
    "x85 = a018.count('d2')\n",
    "\n",
    "a125 = [0]\n",
    "a125.insert(0, x80)\n",
    "a125.insert(1, x81)\n",
    "a125.insert(2, x82)\n",
    "a125.insert(3, x83)\n",
    "a125.insert(4, x84)\n",
    "a125.insert(5, x85)\n",
    "a125.pop(6)\n",
    "\n",
    "x90 = (a030.count('u0') + a031.count('u0') + a032.count('u0') +\n",
    "       a033.count('u0') + a034.count('u0') + a036.count('u0')) \n",
    "\n",
    "x91 = (a030.count('u1') + a031.count('u1') + a032.count('u1') +\n",
    "       a033.count('u1') + a034.count('u1') + a036.count('u1'))\n",
    "\n",
    "x92 = (a030.count('u2') + a031.count('u2') + a032.count('u2') +\n",
    "       a033.count('u2') + a034.count('u2') + a036.count('u2'))\n",
    "\n",
    "x93 = (a030.count('d0') + a031.count('d0') + a032.count('d0') +\n",
    "       a033.count('d0') + a034.count('d0') + a036.count('d0'))\n",
    "\n",
    "x94 = (a030.count('d1') + a031.count('d1') + a032.count('d1') +\n",
    "       a033.count('d1') + a034.count('d1') + a036.count('d1'))\n",
    "\n",
    "x95 = (a030.count('d2') + a031.count('d2') + a032.count('d2') +\n",
    "       a033.count('d2') + a034.count('d2') + a036.count('d2'))\n",
    "\n",
    "a126 = [0]\n",
    "a126.insert(0, x90)\n",
    "a126.insert(1, x91)\n",
    "a126.insert(2, x92)\n",
    "a126.insert(3, x93)\n",
    "a126.insert(4, x94)\n",
    "a126.insert(5, x95)\n",
    "a126.pop(6)\n",
    "\n",
    "x100 = (a035.count('u0') + a037.count('u0')) \n",
    "x101 = (a035.count('u1') + a037.count('u1'))\n",
    "x102 = (a035.count('u2') + a037.count('u2'))\n",
    "x103 = (a035.count('d0') + a037.count('d0'))\n",
    "x104 = (a035.count('d1') + a037.count('d1'))\n",
    "x105 = (a035.count('d2') + a037.count('d2'))\n",
    "\n",
    "a127 = [0]\n",
    "a127.insert(0, x100)\n",
    "a127.insert(1, x101)\n",
    "a127.insert(2, x102)\n",
    "a127.insert(3, x103)\n",
    "a127.insert(4, x104)\n",
    "a127.insert(5, x105)\n",
    "a127.pop(6)\n",
    "\n",
    "x110 = a038.count('u0') \n",
    "x111 = a038.count('u1')\n",
    "x112 = a038.count('u2')\n",
    "x113 = a038.count('d0')\n",
    "x114 = a038.count('d1')\n",
    "x115 = a038.count('d2')\n",
    "\n",
    "a128 = [0]\n",
    "a128.insert(0, x110)\n",
    "a128.insert(1, x111)\n",
    "a128.insert(2, x112)\n",
    "a128.insert(3, x113)\n",
    "a128.insert(4, x114)\n",
    "a128.insert(5, x115)\n",
    "a128.pop(6)\n",
    "\n",
    "a13 = [a123, a124, a125, a126, a127, a128]\n",
    "a13 = array(a13)\n",
    "\n",
    "\"\"\"It looks visually.\n",
    "a13 = array( [[2.0, 1.0, 1.0, 1.0, 1.0, 0.0], \n",
    "              [0.0, 1.0, 0.0, 0.0, 0.0, 1.0], \n",
    "              [0.0, 0.0, 1.0, 0.0, 0.0, 0.0], \n",
    "              [1.0, 1.0, 0.0, 2.0, 1.0, 1.0], \n",
    "              [0.0, 0.0, 1.0, 0.0, 1.0, 0.0], \n",
    "              [0.0, 0.0, 0.0, 0.0, 0.0, 1.0]])\"\"\"\n",
    "\n",
    "# V = 4/3πR**3\n",
    "# The formula can be changed after updating the geometric shape of a quark core\n",
    "# In accordance with the existing representation\n",
    "# v - volume; u - quark \"u\"; d - quark \"d\"; n - neutron; p - proton\n",
    "# i - inner; o - outer\n",
    "    \n",
    "vu = 4/3 * Algorithm.π * (abs(Algorithm.qrn)**3 + Algorithm.qrp**3)/2\n",
    "vd = vu\n",
    "vn = 4/3 * Algorithm.π * Algorithm.rn**3\n",
    "vp = 4/3 * Algorithm.π * Algorithm.rp**3\n",
    "vrpc = 4/3 * Algorithm.π * Algorithm.rpc**3\n",
    "vrnc = 4/3 * Algorithm.π * Algorithm.rnc**3\n",
    "vrpi = 4/3 * Algorithm.π * Algorithm.rpi**3 - vrpc\n",
    "vrpo = vp - vrpc - vrpi\n",
    "vrni = 4/3 * Algorithm.π * Algorithm.rni**3 - vrnc\n",
    "vrno = vn - vrnc - vrni\n",
    "ve = 4/3 * Algorithm.π * (Algorithm.de/2)**3\n",
    "mpc = Algorithm.mp * 0.91\n",
    "mnc = Algorithm.mn * 0.91\n",
    "mpi = Algorithm.mp * 0.09 * (vrpi/vrpo)\n",
    "mni = Algorithm.mn * 0.09 * (vrni/vrno)\n",
    "mpo = Algorithm.mp - mpc - mpi\n",
    "mno = Algorithm.mn - mnc - mni\n",
    "    \n",
    "bq = array ([Algorithm.SHELLP0, Algorithm.SHELLP1, Algorithm.SHELLP2, \n",
    "             Algorithm.SHELLN0, Algorithm.SHELLN1, Algorithm.SHELLN2])\n",
    "    \n",
    "bv = array ([vrpc, vrpi, vrpo, vrnc, vrni, vrno])\n",
    "    \n",
    "bm = array ([mpc, mpi, mpo, mnc, mni, mno])\n",
    "\n",
    "# Calculation of the charge in the electric charges of an electron for the\n",
    "# core and shells of the \"u\" and \"d\" quarks, and their twins.\n",
    "# The numbers from [0] to [2] refer to the \"u\" quark, and his twin.\n",
    "# The numbers from [3] to [5] refer to the \"d\" quark, and his twin.\n",
    "xq02 = linalg.solve(a02, bq)\n",
    "xq13 = linalg.solve(a13, bq)\n",
    "\n",
    "# Calculation of volume for core and shells of the \"u\" and \"d\" quarks, \n",
    "# and their twins.\n",
    "# The numbers from [0] to [2] refer to the \"u\" quark, and his twin.\n",
    "# The numbers from [3] to [5] refer to the \"d\" quark, and his twin.\n",
    "xv02 = linalg.solve(a02, bv)\n",
    "xv13 = linalg.solve(a13, bv)\n",
    "\n",
    "# Calculation of mass for core and shells of the \"u\" and \"d\" quarks, \n",
    "# and their twins.\n",
    "# The numbers from [0] to [2] refer to the \"u\" quark, and his twin.\n",
    "# The numbers from [3] to [5] refer to the \"d\" quark, and his twin.\n",
    "xm02 = linalg.solve(a02, bm)\n",
    "xm13 = linalg.solve(a13, bm)\n",
    "\n",
    "# Calculation of the charge for the core and shells of the \"u\" and \"d\" \n",
    "#quarks, and their twins.\n",
    "# The numbers from [0] to [2] refer to the \"u\" quark, and his twin.\n",
    "# The numbers from [3] to [5] refer to the \"d\" quark, and his twin.\n",
    "for i, item in enumerate(xq02):\n",
    "    xq02[i] *= Algorithm.qe\n",
    "    \n",
    "for i, item in enumerate(xq13):\n",
    "    xq13[i] *= Algorithm.qe\n",
    "\n",
    "unit = Algorithm(xq02, xq13, xv02, xv13, xm02, xm13)\n",
    "\n",
    "\"\"\"Calculation of values for \"u\" and \"d\" quarks, their twins\"\"\"\n",
    "\n",
    "class Wave():\n",
    "    constant = unit.constanth/unit.constantc\n",
    "    def __init__ (self, wave0, wave1):\n",
    "        self.wave0 = wave0\n",
    "        self.wave1 = wave1\n",
    "        \n",
    "wave0 = 1/unit.xm02\n",
    "wave1 = 1/unit.xm13\n",
    "\n",
    "for i, item in enumerate(wave0): \n",
    "    wave0[i] *= Wave.constant\n",
    "for i, item in enumerate(wave1): \n",
    "    wave1[i] *= Wave.constant\n",
    "    \n",
    "unit2 = Wave(wave0, wave1)\n",
    "\n",
    "class Electromagnetism():\n",
    "    constant1 = 1/(2 * unit.constantε0 * unit.constanth * unit.constantc)\n",
    "    constant2 = 1/(2 * unit.constantε02 * unit.constanth * unit.constantc)\n",
    "    def __init__ (self, electro0, electro1, electro02, electro12):\n",
    "        self.electro0 = electro0\n",
    "        self.electro1 = electro1\n",
    "        self.electro02 = electro02\n",
    "        self.electro12 = electro12\n",
    "        \n",
    "electro0 = unit.xq02 ** 2\n",
    "electro1 = unit.xq13 ** 2\n",
    "\n",
    "electro02 = unit.xq02 ** 2\n",
    "electro12 = unit.xq13 ** 2\n",
    "\n",
    "for i, item in enumerate(electro0): \n",
    "    electro0[i] *= Electromagnetism.constant1\n",
    "for i, item in enumerate(electro1): \n",
    "    electro1[i] *= Electromagnetism.constant1\n",
    "    \n",
    "for i, item in enumerate(electro02): \n",
    "    electro02[i] *= Electromagnetism.constant2\n",
    "for i, item in enumerate(electro12): \n",
    "    electro12[i] *= Electromagnetism.constant2\n",
    "    \n",
    "unit3 = Electromagnetism(electro0, electro1, electro02, electro12)\n",
    "\n",
    "class Gravity():\n",
    "    constant3 = 2 * unit.π * unit.constantg/(unit.constanth * unit.constantc)\n",
    "    constant4 = 2 * unit.π * unit.constantg2/(unit.constanth * unit.constantc)\n",
    "    def __init__ (self, grav0, grav1, grav02, grav12):\n",
    "        self.grav0 = grav0\n",
    "        self.grav1 = grav1\n",
    "        self.grav02 = grav02\n",
    "        self.grav12 = grav12\n",
    "        \n",
    "grav0 = unit.xm02 ** 2\n",
    "grav1 = unit.xm13 ** 2\n",
    "\n",
    "grav02 = unit.xm02 ** 2\n",
    "grav12 = unit.xm13 ** 2\n",
    "\n",
    "for i, item in enumerate(grav0): \n",
    "    grav0[i] *= Gravity.constant3\n",
    "for i, item in enumerate(grav1): \n",
    "    grav1[i] *= Gravity.constant3\n",
    "    \n",
    "for i, item in enumerate(grav02): \n",
    "    grav02[i] *= Gravity.constant4\n",
    "for i, item in enumerate(grav12): \n",
    "    grav12[i] *= Gravity.constant4\n",
    "        \n",
    "unit4 = Gravity(grav0, grav1, grav02, grav12)\n",
    "\n",
    "class Frequency():\n",
    "    def __init__ (self, frequency0, frequency1):\n",
    "        self.frequency0 = frequency0\n",
    "        self.frequency1 = frequency1\n",
    "        \n",
    "frequency0 = 1/unit2.wave0\n",
    "frequency1 = 1/unit2.wave1\n",
    "\n",
    "for i, item in enumerate(frequency0):\n",
    "       frequency0[i] *= unit.constantc\n",
    "for i, item in enumerate(frequency1):\n",
    "       frequency1[i] *= unit.constantc\n",
    "        \n",
    "unit5 = Frequency(frequency0, frequency1)\n",
    "\n",
    "\"\"\"Formation of a data set for a proton, neutron, their twins,\"\"\" \n",
    "\"\"\"a carrier of an electromagnetic field. \"\"\"    \n",
    "\n",
    "class Particles():\n",
    "    def __init__ (self, proton0, proton1, neutron0, neutron1, melectron_charge,\n",
    "                 melectron_mass, melectron_volume):\n",
    "        self.proton0 = proton0\n",
    "        self.proton1 = proton1\n",
    "        self.neutron0 = neutron0\n",
    "        self.neutron1 = neutron1\n",
    "        self.melectron_charge = melectron_charge\n",
    "        self.melectron_mass = melectron_mass\n",
    "        self.melectron_volume = melectron_volume        \n",
    "        \n",
    "# Matrices from a0 to a3 from the Algorithm class are used to form a data set\n",
    "# for a proton, neutron, and their twins. \n",
    "# The x...02 values are used for the matrices a0 and a2.\n",
    "# The x...13 values are used for the matrices a1 and a3.\n",
    "Newproton = namedtuple('Newproton', 'name1 charge name2 mass name3 volume')\n",
    "\n",
    "proton0 = [[1, 'pq1', unit.xq02[0], 'pm1', unit.xm02[0], 'pv1', unit.xv02[0]],\n",
    "           [2, 'pq2', unit.xq02[1], 'pm2', unit.xm02[1], 'pv2', unit.xv02[1]],\n",
    "           [3, 'pq3', unit.xq02[0], 'pm3', unit.xm02[0], 'pv3', unit.xv02[0]],\n",
    "           [4, 'pq4', unit.xq02[2], 'pm4', unit.xm02[2], 'pv4', unit.xv02[2]],\n",
    "           [5, 'pq5', unit.xq02[1], 'pm5', unit.xm02[1], 'pv5', unit.xv02[1]],           \n",
    "           [6, 'pq6', unit.xq02[3], 'pm6', unit.xm02[3], 'pv6', unit.xv02[3]],           \n",
    "           [7, 'pq7', unit.xq02[2], 'pm7', unit.xm02[2], 'pv7', unit.xv02[2]],           \n",
    "           [8, 'pq8', unit.xq02[4], 'pm8', unit.xm02[4], 'pv8', unit.xv02[4]],\n",
    "           [9, 'pq9', unit.xq02[5], 'pm9', unit.xm02[5], 'pv9', unit.xv02[5]]] \n",
    "\n",
    "table3 = PrettyTable(['#', 'Charge sym.', 'Charge in Cl', 'Mass sym.',\n",
    "                      'Mass in kg.', 'Volume sym.', 'Volume in cbm'])\n",
    "\n",
    "for rec in proton0:\n",
    "    table3.add_row(rec) \n",
    "\n",
    "Proton = namedtuple('Proton', 'name1 charge name2 mass name3 volume')\n",
    "proton1 = [[1, 'pq1', unit.xq13[0], 'pm1', unit.xm13[0], 'pv1', unit.xv13[0]], \n",
    "           [2, 'pq2', unit.xq13[1], 'pm2', unit.xm13[1], 'pv2', unit.xv13[1]], \n",
    "           [3, 'pq3', unit.xq13[3], 'pm3', unit.xm13[3], 'pv3', unit.xv13[3]],\n",
    "           [4, 'pq4', unit.xq13[2], 'pm4', unit.xm13[2], 'pv4', unit.xv13[2]],\n",
    "           [5, 'pq6', unit.xq13[4], 'pm6', unit.xm13[4], 'pv6', unit.xv13[4]],           \n",
    "           [6, 'pq5', unit.xq13[0], 'pm5', unit.xm13[0], 'pv5', unit.xv13[0]],\n",
    "           [7, 'pq7', unit.xq13[5], 'pm7', unit.xm13[5], 'pv7', unit.xv13[5]],           \n",
    "           [8, 'pq8', unit.xq13[1], 'pm8', unit.xm13[1], 'pv8', unit.xv13[1]],\n",
    "           [9, 'pq9', unit.xq13[2], 'pm9', unit.xm13[2], 'pv9', unit.xv13[2]]] \n",
    "\n",
    "table4 = PrettyTable(['#', 'Charge sym.', 'Charge in Cl', 'Mass sym.',\n",
    "                      'Mass in kg.', 'Volume sym.', 'Volume in cbm'])\n",
    "for rec in proton1:\n",
    "    table4.add_row(rec)\n",
    "\n",
    "Newneutron = namedtuple('Newneutron', 'name1 charge name2 mass name3 volume')\n",
    "neutron0 = [[1, 'nq1', unit.xq02[3], 'nm1', unit.xm02[3], 'nv1', unit.xv02[3]], \n",
    "            [2, 'nq2', unit.xq02[4], 'nm2', unit.xm02[4], 'nv2', unit.xv02[4]],\n",
    "            [3, 'nq5', unit.xq02[3], 'nm5', unit.xm02[3], 'nv5', unit.xv02[3]],\n",
    "            [4, 'nq4', unit.xq02[5], 'nm4', unit.xm02[5], 'nv4', unit.xv02[5]],\n",
    "            [5, 'nq8', unit.xq02[4], 'nm8', unit.xm02[4], 'nv8', unit.xv02[4]],            \n",
    "            [6, 'nq3', unit.xq02[0], 'nm3', unit.xm02[0], 'nv3', unit.xv02[0]],\n",
    "            [7, 'nq8', unit.xq02[4], 'nm8', unit.xm02[4], 'nv8', unit.xv02[4]],            \n",
    "            [8, 'nq6', unit.xq02[1], 'nm6', unit.xm02[1], 'nv6', unit.xv02[1]],\n",
    "            [9, 'nq7', unit.xq02[2], 'nm7', unit.xm02[2], 'nv7', unit.xv02[2]]]\n",
    "\n",
    "table5 = PrettyTable(['#', 'Charge sym.', 'Charge in Cl', 'Mass sym.',\n",
    "                      'Mass in kg.', 'Volume sym.', 'Volume in cbm'])\n",
    "for rec in neutron0:\n",
    "    table5.add_row(rec)\n",
    "\n",
    "Neutron = namedtuple('Neutron', 'name1 charge name2 mass name3 volume')    \n",
    "neutron1 = [[1, 'nq1', unit.xq13[3], 'nm1', unit.xm13[3], 'nv1', unit.xv13[3]], \n",
    "            [2, 'nq2', unit.xq13[4], 'nm2', unit.xm13[4], 'nv2', unit.xv13[4]], \n",
    "            [3, 'nq3', unit.xq13[0], 'nm3', unit.xm13[0], 'nv3', unit.xv13[0]],\n",
    "            [4, 'nq4', unit.xq13[5], 'nm4', unit.xm13[5], 'nv4', unit.xv13[5]],\n",
    "            [5, 'nq6', unit.xq13[1], 'nm6', unit.xm13[1], 'nv6', unit.xv13[1]],\n",
    "            [6, 'nq5', unit.xq13[3], 'nm5', unit.xm13[3], 'nv5', unit.xv13[3]],            \n",
    "            [7, 'nq7', unit.xq13[2], 'nm7', unit.xm13[2], 'nv7', unit.xv13[2]],\n",
    "            [8, 'nq8', unit.xq13[4], 'nm8', unit.xm13[4], 'nv8', unit.xv13[4]],\n",
    "            [9, 'nq9', unit.xq13[5], 'nm9', unit.xm13[5], 'nv9', unit.xv13[5]]]\n",
    "\n",
    "table6 = PrettyTable(['#', 'Charge sym.', 'Charge in Cl', 'Mass sym.',\n",
    "                      'Mass in kg.', 'Volume sym.', 'Volume in cbm'])\n",
    "for rec in neutron1:\n",
    "    table6.add_row(rec)\n",
    "\n",
    "proton0 = list(zip(* proton0))\n",
    "proton1 = list(zip(* proton1))\n",
    "neutron0 = list(zip(* neutron0))\n",
    "neutron1 = list(zip(* neutron1))\n",
    "\n",
    "proton0_min_charge = min((proton0)[2], key=abs)\n",
    "proton1_min_charge = min((proton1)[2], key=abs)\n",
    "neutron0_min_charge = min((neutron0)[2], key=abs)\n",
    "neutron1_min_charge = min((neutron1)[2], key=abs)\n",
    "\n",
    "# Let's compare the minimum values of charges in a new proton, new neutron, \n",
    "# neutron, proton and find the value of a point charged particle\n",
    "\n",
    "if (proton0_min_charge == neutron0_min_charge and  \n",
    "    proton1_min_charge == neutron1_min_charge and \n",
    "    proton0_min_charge == proton1_min_charge):\n",
    "    \n",
    "# Algorithm for finding GCD by subtraction\n",
    "   \n",
    "    a = proton0_min_charge\n",
    "    b = unit.qe2\n",
    "    while a != b:\n",
    "        if a > b:\n",
    "            a = a - b\n",
    "        else:\n",
    "            b = b - a\n",
    "\n",
    "# A point charged particle(melectron) - a carrier of an electromagnetic field.\n",
    "melectron_charge = a\n",
    "        \n",
    "# Find the mass of a point charged particle.\n",
    "melectron_mass = unit.me/(unit.qe2/melectron_charge)\n",
    " \n",
    "# Minimum_volume particles. \n",
    "melectron_volume = ve/(unit.qe2/melectron_charge)\n",
    "\n",
    "# Let's define a proton, neutron, new proton, new neutron through the definition\n",
    "# of electric charge.\n",
    "\n",
    "if (sum(neutron0[2]) > sum(neutron1[2]) and sum(proton0[2]) == sum(proton1[2])): \n",
    "    neutron = neutron1 \n",
    "    new_neutron = neutron0 \n",
    "    proton = proton1 \n",
    "    new_proton = proton0\n",
    "else:\n",
    "    print('Algorithm requires verification.')     \n",
    "                         \n",
    "unit6 = Particles(proton0, proton1, neutron0, neutron1, melectron_charge,\n",
    "                 melectron_mass, melectron_volume)\n",
    "\n",
    "\"\"\"Calculation of wave, frequency, gravitational values for\"\"\"\n",
    "\"\"\"proton and neutron, their twins.\"\"\"\n",
    "# new neutron\n",
    "nnq = unit6.neutron0[2]\n",
    "nnq = array(nnq)\n",
    "# neutron\n",
    "nq = unit6.neutron1[2]\n",
    "nq = array(nq)\n",
    "# new proton\n",
    "npq = unit6.proton0[2]\n",
    "npq = array(npq)\n",
    "# proton\n",
    "pq = unit6.proton1[2]\n",
    "pq = array(pq)\n",
    "\n",
    "# new neutron\n",
    "nnm = unit6.neutron0[4]\n",
    "nnm = array(nnm)\n",
    "# neutron\n",
    "nm = unit6.neutron1[4]\n",
    "nm = array(nm)\n",
    "# new proton\n",
    "npm = unit6.proton0[4]\n",
    "npm = array(npm)\n",
    "# proton\n",
    "pm = unit6.proton1[4]\n",
    "pm = array(pm)\n",
    "\n",
    "class Wavep():\n",
    "    constant = unit.constanth/unit.constantc\n",
    "    def __init__ (self, wave01, wave11, wave21, wave31):\n",
    "        self.wave01 = wave01\n",
    "        self.wave11 = wave11\n",
    "        self.wave21 = wave21\n",
    "        self.wave31 = wave31\n",
    "# new neutron        \n",
    "wave01 = 1/nnm\n",
    "# neutron\n",
    "wave11 = 1/nm\n",
    "# new proton\n",
    "wave21 = 1/npm\n",
    "# proton\n",
    "wave31 = 1/pm\n",
    "\n",
    "for i, item in enumerate(wave01): \n",
    "    wave01[i] *= Wavep.constant\n",
    "for i, item in enumerate(wave11): \n",
    "    wave11[i] *= Wavep.constant\n",
    "for i, item in enumerate(wave21): \n",
    "    wave21[i] *= Wavep.constant\n",
    "for i, item in enumerate(wave31): \n",
    "    wave31[i] *= Wavep.constant\n",
    "    \n",
    "unit7 = Wavep(wave01, wave11, wave21, wave31)\n",
    "\n",
    "class Electromagnetismp():\n",
    "    constant1 = 1/(2 * unit.constantε0 * unit.constanth * unit.constantc)\n",
    "    constant2 = 1/(2 * unit.constantε02 * unit.constanth * unit.constantc)\n",
    "    def __init__ (self, electro01, electro11, electro03, electro13,\n",
    "                  electro02, electro14, electro04, electro15):\n",
    "        self.electro01 = electro01\n",
    "        self.electro11 = electro11\n",
    "        self.electro03 = electro03\n",
    "        self.electro13 = electro13\n",
    "        self.electro02 = electro02\n",
    "        self.electro14 = electro14\n",
    "        self.electro04 = electro04\n",
    "        self.electro15 = electro15\n",
    "# new neutron         \n",
    "electro01 = nnq ** 2\n",
    "electro11 = nnq ** 2\n",
    "# neutron \n",
    "electro03 = nq ** 2\n",
    "electro13 = nq ** 2\n",
    "# new proton\n",
    "electro02 = npq ** 2\n",
    "electro14 = npq ** 2\n",
    "# proton\n",
    "electro04 = pq ** 2\n",
    "electro15 = pq ** 2\n",
    "\n",
    "for i, item in enumerate(electro01): \n",
    "    electro01[i] *= Electromagnetismp.constant1\n",
    "for i, item in enumerate(electro11): \n",
    "    electro11[i] *= Electromagnetismp.constant2\n",
    "    \n",
    "for i, item in enumerate(electro03): \n",
    "    electro03[i] *= Electromagnetismp.constant1\n",
    "for i, item in enumerate(electro13): \n",
    "    electro13[i] *= Electromagnetismp.constant2\n",
    "    \n",
    "for i, item in enumerate(electro02): \n",
    "    electro02[i] *= Electromagnetismp.constant1\n",
    "for i, item in enumerate(electro14): \n",
    "    electro14[i] *= Electromagnetismp.constant2\n",
    "    \n",
    "for i, item in enumerate(electro04): \n",
    "    electro04[i] *= Electromagnetismp.constant1\n",
    "for i, item in enumerate(electro15): \n",
    "    electro15[i] *= Electromagnetismp.constant2\n",
    "    \n",
    "unit8 = Electromagnetismp(electro01, electro11, electro03, electro13,\n",
    "                         electro02, electro14, electro04, electro15)\n",
    "\n",
    "class Gravityp():\n",
    "    constant3 = 2 * unit.π * unit.constantg/(unit.constanth * unit.constantc)\n",
    "    constant4 = 2 * unit.π * unit.constantg2/(unit.constanth * unit.constantc)\n",
    "    def __init__ (self, grav01, grav11, grav03, grav13, grav02, grav14,\n",
    "                 grav04, grav15):\n",
    "        self.grav01 = grav01\n",
    "        self.grav11 = grav11\n",
    "        self.grav03 = grav03\n",
    "        self.grav13 = grav13\n",
    "        self.grav02 = grav02\n",
    "        self.grav14 = grav14\n",
    "        self.grav04 = grav04\n",
    "        self.grav15 = grav15\n",
    "# new neutron        \n",
    "grav01 = nnm ** 2\n",
    "grav11 = nnm ** 2\n",
    "# neutron\n",
    "grav03 = nm ** 2\n",
    "grav13 = nm ** 2\n",
    "# new proton\n",
    "grav02 = npm ** 2\n",
    "grav14 = npm ** 2\n",
    "# proton\n",
    "grav04 = pm ** 2\n",
    "grav15 = pm ** 2\n",
    "\n",
    "for i, item in enumerate(grav01): \n",
    "    grav01[i] *= Gravityp.constant3\n",
    "for i, item in enumerate(grav11): \n",
    "    grav11[i] *= Gravityp.constant4\n",
    "    \n",
    "for i, item in enumerate(grav03): \n",
    "    grav03[i] *= Gravityp.constant3\n",
    "for i, item in enumerate(grav13): \n",
    "    grav13[i] *= Gravityp.constant4\n",
    "    \n",
    "for i, item in enumerate(grav02): \n",
    "    grav02[i] *= Gravityp.constant3\n",
    "for i, item in enumerate(grav14): \n",
    "    grav14[i] *= Gravityp.constant4\n",
    "    \n",
    "for i, item in enumerate(grav04): \n",
    "    grav04[i] *= Gravityp.constant3\n",
    "for i, item in enumerate(grav15): \n",
    "    grav15[i] *= Gravityp.constant4\n",
    "        \n",
    "unit9 = Gravityp(grav01, grav11, grav03, grav13, grav02, grav14,\n",
    "                 grav04, grav15)\n",
    "\n",
    "class Frequencyp():\n",
    "    def __init__ (self, frequency02, frequency03, \n",
    "                  frequency04, frequency05):\n",
    "        self.frequency02 = frequency02\n",
    "        self.frequency03 = frequency03\n",
    "        self.frequency04 = frequency04\n",
    "        self.frequency05 = frequency05\n",
    "# new neutron        \n",
    "frequency02 = 1/unit7.wave01\n",
    "# neutron\n",
    "frequency03 = 1/unit7.wave11\n",
    "# new proton\n",
    "frequency04 = 1/unit7.wave21\n",
    "# proton\n",
    "frequency05 = 1/unit7.wave31\n",
    "\n",
    "for i, item in enumerate(frequency02):\n",
    "       frequency02[i] *= unit.constantc\n",
    "for i, item in enumerate(frequency03):\n",
    "       frequency03[i] *= unit.constantc\n",
    "        \n",
    "for i, item in enumerate(frequency04):\n",
    "       frequency04[i] *= unit.constantc\n",
    "for i, item in enumerate(frequency05):\n",
    "       frequency05[i] *= unit.constantc\n",
    "        \n",
    "unit10 = Frequencyp(frequency02, frequency03, \n",
    "                    frequency04, frequency05)\n",
    "\n",
    "class Practice():\n",
    "# The relationship of frequency and wavelength at different speeds.\n",
    "# Speed - v\n",
    "\n",
    "    def __init__ (self, frequenn, frequennn, frequenp,\n",
    "                  frequennp, wavelengthn, wavelengthnn,\n",
    "                  wavelengthp, wavelengthnp, v):\n",
    "        self.frequenn = frequenn\n",
    "        self.frequennn = frequennn\n",
    "        self.frequenp = frequenp\n",
    "        self.frequennp = frequennp\n",
    "        self.wavelengthn = wavelengthn\n",
    "        self.wavelengthnn = wavelengthnn\n",
    "        self.wavelengthp = wavelengthp\n",
    "        self.wavelengthnp = wavelengthnp\n",
    "        self.v = v\n",
    "        \n",
    "frequenn = [1/unit7.wave11[0], 1/unit7.wave11[1], \n",
    "            1/unit7.wave11[2], 1/unit7.wave11[3], \n",
    "            1/unit7.wave11[4], 1/unit7.wave11[5], \n",
    "            1/unit7.wave11[6], 1/unit7.wave11[7], \n",
    "            1/unit7.wave11[8]]\n",
    "\n",
    "frequennn = [1/unit7.wave01[0], 1/unit7.wave01[1], \n",
    "             1/unit7.wave01[2], 1/unit7.wave01[3], \n",
    "             1/unit7.wave01[4], 1/unit7.wave01[5], \n",
    "             1/unit7.wave01[6], 1/unit7.wave01[7], \n",
    "             1/unit7.wave01[8]]\n",
    "\n",
    "frequenp = [1/unit7.wave31[0], 1/unit7.wave31[1], \n",
    "            1/unit7.wave31[2], 1/unit7.wave31[3], \n",
    "            1/unit7.wave31[4], 1/unit7.wave31[5], \n",
    "            1/unit7.wave31[6], 1/unit7.wave31[7], \n",
    "            1/unit7.wave31[8]]\n",
    "\n",
    "frequennp = [1/unit7.wave21[0], 1/unit7.wave21[1], \n",
    "             1/unit7.wave21[2], 1/unit7.wave21[3], \n",
    "             1/unit7.wave21[4], 1/unit7.wave21[5], \n",
    "             1/unit7.wave21[6], 1/unit7.wave21[7], \n",
    "             1/unit7.wave21[8]]\n",
    "\n",
    "# neutron        \n",
    "for j in range(8):\n",
    "    wavelengthn = np.random.uniform(unit7.wave11[j], unit7.wave11[j+1], size=(1, 8000))\n",
    "    frequenn = 1/wavelengthn\n",
    "    v = np.random.uniform(- Algorithm.constantc, Algorithm.constantc, size=(1, 8000))\n",
    "\n",
    "for i, item in enumerate(frequenn):\n",
    "    frequenn[i] *= v[i]  \n",
    "# new neutron \n",
    "for j in range(8):\n",
    "    wavelengthnn = np.random.uniform(unit7.wave01[j], unit7.wave01[j+1], size=(1, 8000))\n",
    "    frequennn = 1/wavelengthnn        \n",
    "for i, item in enumerate(frequennn):\n",
    "    frequennn *= v[i]\n",
    "# proton     \n",
    "for j in range(8):\n",
    "    wavelengthp = np.random.uniform(unit7.wave31[j], unit7.wave31[j+1], size=(1, 8000))\n",
    "    frequenp = 1/wavelengthp        \n",
    "for i, item in enumerate(frequenp):\n",
    "    frequenp[i] *= v[i]\n",
    "# new proton    \n",
    "for j in range(8):\n",
    "    wavelengthnp = np.random.uniform(unit7.wave21[j], unit7.wave21[j+1], size=(1, 8000))\n",
    "    frequennp = 1/wavelengthnp        \n",
    "for i, item in enumerate(frequennp):\n",
    "    frequennp[i] *= v[i]\n",
    "        \n",
    "unit11 = Practice(frequenn, frequennn, frequenp,\n",
    "                  frequennp, wavelengthn, wavelengthnn,\n",
    "                  wavelengthp, wavelengthnp, v)\n",
    "\n",
    "Basic_design_data = [[1, 'Proton core volume \\n', vrpc],\n",
    "                    [2, 'Neutron core volume \\n', vrnc],\n",
    "                    [3, 'The volume of the inner shell of the proton \\n', vrpi],\n",
    "                    [4, 'The volume of the outer shell of the proton \\n', vrpo],\n",
    "                    [5, 'The volume of the inner shell of the neutron \\n', vrni],\n",
    "                    [6, 'The volume of the outer shell of the neutron \\n', vrno],\n",
    "                    [7, 'Proton core mass \\n', mpc],\n",
    "                    [8, 'Neutron core mass \\n', mnc],\n",
    "                    [9, 'The mass of the inner shell of the proton \\n', mpi],\n",
    "                    [10, 'The mass of the inner shell of the neutron \\n', mni],\n",
    "                    [11, 'The mass of the outer shell of the proton \\n', mpo],\n",
    "                    [12, 'The mass of the outer shell of the neutron \\n', mno],\n",
    "                    [13, 'The electric charge of the new quark core \"u\" \\n', unit.xq02[0]],\n",
    "                    [14, 'The electric charge of the quark nucleus \"u\" \\n', unit.xq13[0]],\n",
    "                    [15, 'The electric charge of the inner new quark \\n'\n",
    "                     'shell \"u\" \\n', unit.xq02[1]],\n",
    "                    [16, 'The electric charge of the inner quark \\n'\n",
    "                     'shell \"u\" \\n',unit.xq13[1]],\n",
    "                    [17, 'The electric charge of the outer new quark \\n'\n",
    "                     'shell \"u\" \\n', unit.xq02[2]],\n",
    "                    [18, 'The electric charge of the outer quark \\n'\n",
    "                     'shell \"u\" \\n',unit.xq13[2]],\n",
    "                    [19, 'The mass of the new quark core \"u\" \\n', unit.xm02[0]],\n",
    "                    [20, 'The mass of the quark nucleus \"u\" \\n', unit.xm13[0]],\n",
    "                    [21, 'The mass of the inner new quark shell \"u\" \\n', unit.xm02[1]],\n",
    "                    [22, 'The mass of the inner quark shell \"u\" \\n',unit.xm13[1]],\n",
    "                    [23, 'The mass of the outer new quark shell \"u\" \\n', unit.xm02[2]],\n",
    "                    [24, 'The mass of the outer quark shell \"u\" \\n',unit.xm13[2]],\n",
    "                    [25, 'The volume of the new quark core \"u\" \\n', unit.xv02[0]],\n",
    "                    [26, 'The volume of the quark nucleus \"u\" \\n', unit.xv13[0]],\n",
    "                    [27, 'The volume of the inner new quark shell \"u\" \\n', unit.xv02[1]],\n",
    "                    [28, 'The volume of the inner quark shell \"u\" \\n',unit.xv13[1]],\n",
    "                    [29, 'The volume of the outer new quark shell \"u\" \\n', unit.xv02[2]],\n",
    "                    [30, 'The volume of the outer quark shell \"u\" \\n',unit.xv13[2]],                     \n",
    "                    [31, 'Matrix of the proton + neutron for\\n'\n",
    "                     'calculating the values of the quarks \\n'\n",
    "                     '\"u\" and \"d\".\\n \\n'                     \n",
    "                     'The first column shows the quantity \\n'\n",
    "                     'for the \"u\" quark core. \\n'\n",
    "                     'The second column shows the amount for \\n'\n",
    "                     'the inner \\n'\n",
    "                     'shell of the  quark \"u\". \\n'\n",
    "                     'The third column shows the amount for \\n'\n",
    "                     'the outer shell of the quark \"u\".\\n'\n",
    "                     'The fourth column shows the quantity \\n'\n",
    "                     'for the \"d\" quark core. \\n'\n",
    "                     'The fifth column shows the amount \\n'\n",
    "                     'for the inner shell of the quark \"d\". \\n'\n",
    "                     'The sixth column shows the amount \\n'\n",
    "                     'for the outer \\n'\n",
    "                     'shell of the quark \"d\". \\n',a13],                     \n",
    "                    [32, 'Matrix of the new proton + \\n'\n",
    "                     'neutron for\\n'\n",
    "                     'calculating the values of the new \\n'\n",
    "                     'quarks\\n'\n",
    "                     '\"u\" and \"d\".\\n'\n",
    "                     'The first line is the core of the \\n'\n",
    "                     'new proton.\\n'\n",
    "                     'The second line is the inner \\n'\n",
    "                     'shell of the new proton.\\n'\n",
    "                     'The third line is the outer \\n'\n",
    "                     'shell of the new proton.\\n'\n",
    "                     'The fourth line is the core of the\\n'\n",
    "                     'new neutron.\\n'\n",
    "                     'The fifth line is the inner shell of the\\n'\n",
    "                     'new neutron.\\n'\n",
    "                     'The sixth line is the outer shell of the\\n'\n",
    "                     'new neutron.\\n', a02]]\n",
    "\n",
    "table2 = PrettyTable(['#', 'Description', 'Design data'])\n",
    "for rec in Basic_design_data:\n",
    "    table2.add_row(rec)\n",
    "    \n",
    "Smallest_electrical_charge = [[1, 'Electric charge \\n', unit6.melectron_charge],\n",
    "                              [2, 'Mass \\n', unit6.melectron_mass],\n",
    "                              [3, 'Volume', unit6.melectron_volume]]\n",
    "table7 = PrettyTable(['#', 'Description', 'Design data'])\n",
    "\n",
    "for rec in Smallest_electrical_charge:\n",
    "                              table7.add_row(rec)\n",
    "        \n",
    "# Visualization of the distribution of electric charge\n",
    "# in a proton, neutron and their twins along the shells.\n",
    "\n",
    "x = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8])\n",
    "\n",
    "# proton free state\n",
    "yp  = np.array([unit.xq13[0], unit.xq13[1], unit.xq13[3], unit.xq13[2], unit.xq13[4],\n",
    "                unit.xq13[0], unit.xq13[5], unit.xq13[1], unit.xq13[2]])  \n",
    "\n",
    "# new proton free state\n",
    "znp = np.array([unit.xq02[0], unit.xq02[1], unit.xq02[0], unit.xq02[2],\n",
    "                unit.xq02[1], unit.xq02[3], unit.xq02[2], unit.xq02[4], unit.xq02[5]])  \n",
    "\n",
    "xx = np.linspace(x.min(),x.max(), 1000)\n",
    "fig, axs = plt.subplots(1, 1, figsize=(14, 11))\n",
    "\n",
    "itp1 = PchipInterpolator(x,yp)\n",
    "itp2 = PchipInterpolator(x,znp)\n",
    "window_size, poly_order = 57, 2\n",
    "\n",
    "ypyp_sg = savgol_filter(itp1(xx), window_size, poly_order)\n",
    "znpznp_sg = savgol_filter(itp2(xx), window_size, poly_order)\n",
    "\n",
    "axs.plot(x, yp, 'gs', label= 'The proton')\n",
    "axs.plot(xx, ypyp_sg, 'green', label= \"Smoothed curve\")\n",
    "\n",
    "axs.plot(x, znp, 'bs', label= 'The new proton')\n",
    "axs.plot(xx, znpznp_sg, 'b', label= \"Smoothed curve\")\n",
    "\n",
    "# neutron free state\n",
    "yn  = np.array([unit.xq13[3], unit.xq13[4], unit.xq13[0], unit.xq13[5], unit.xq13[1],\n",
    "                unit.xq13[3], unit.xq13[2], unit.xq13[4], unit.xq13[5]])  \n",
    "\n",
    "# new neutron free state\n",
    "znn = np.array([unit.xq02[3], unit.xq02[4], unit.xq02[3], unit.xq02[5],\n",
    "                unit.xq02[4], unit.xq02[0], unit.xq02[4], unit.xq02[1], unit.xq02[2]])  \n",
    "\n",
    "itp3 = PchipInterpolator(x,yn)\n",
    "itp4 = PchipInterpolator(x,znn)\n",
    "\n",
    "ynyn_sg = savgol_filter(itp3(xx), window_size, poly_order)\n",
    "znnznn_sg = savgol_filter(itp4(xx), window_size, poly_order)\n",
    "\n",
    "axs.plot(x, yn, 'ms', label= 'The neutron')\n",
    "axs.plot(xx, ynyn_sg, 'm', label= \"Smoothed curve\")\n",
    "\n",
    "axs.plot(x, znn, 'ys', label= 'The new neutron')\n",
    "axs.plot(xx, znnznn_sg, 'y', label= \"Smoothed curve\")\n",
    "\n",
    "# or fit to a global function for neutron and new neutron \n",
    "def func(x, A, B, x0, sigma):\n",
    "    return abs(A)+B*np.tanh((x-x0)/sigma)\n",
    "\n",
    "fit, _ = curve_fit(func, x, yn)\n",
    "ynyn_fit = func(xx, *fit)\n",
    "\n",
    "fit, _ = curve_fit(func, x, znn)\n",
    "znnznn_fit = func(xx, *fit)\n",
    "\n",
    "axs.plot(xx, ynyn_fit, 'm--', \n",
    "         label=r\"$f(xn) = |A| + B \\tanh\\left(\\frac{x-x_0}{\\sigma}\\right)$\")\n",
    "\n",
    "axs.plot(xx, znnznn_fit, 'y--', \n",
    "         label=r\"$f(xnn) = |A| + B \\tanh\\left(\\frac{x-x_0}{\\sigma}\\right)$\")\n",
    "\n",
    "plt.ylabel('The amount of charge \\n \\n in Cl х Е-19', fontsize=15)\n",
    "plt.xlabel('Shell number', fontsize=15)\n",
    "\n",
    "yticks(fontsize=12)\n",
    "plt.legend(loc='upper left', fontsize=16)\n",
    "grid()         \n",
    "plt.title('THE DISTRIBUTION ELECTRIC CHARGE OVER SHELLS \\n Graph#1.\\n', fontsize=17)\n",
    "\n",
    "# Visualization of the distribution of volume\n",
    "# in a proton, neutron and their twins along the shells.\n",
    "\n",
    "x = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8])\n",
    "\n",
    "# proton free state\n",
    "ypv  = np.array([unit.xv13[0], unit.xv13[1], unit.xv13[3], unit.xv13[2], unit.xv13[4],\n",
    "                unit.xv13[0], unit.xv13[5], unit.xv13[1], unit.xv13[2]])  \n",
    "\n",
    "# new proton free state\n",
    "znpv = np.array([unit.xv02[0], unit.xv02[1], unit.xv02[0], unit.xv02[2],\n",
    "                unit.xv02[1], unit.xv02[3], unit.xv02[2], unit.xv02[4], unit.xv02[5]])  \n",
    "\n",
    "xx = np.linspace(x.min(),x.max(), 1000)\n",
    "fig, axs = plt.subplots(1, 1, figsize=(14, 11))\n",
    "\n",
    "itp1 = PchipInterpolator(x,ypv)\n",
    "itp2 = PchipInterpolator(x,znpv)\n",
    "window_size, poly_order = 57, 2\n",
    "\n",
    "ypvypv_sg = savgol_filter(itp1(xx), window_size, poly_order)\n",
    "znpvznpv_sg = savgol_filter(itp2(xx), window_size, poly_order)\n",
    "\n",
    "axs.plot(x, ypv, 'gs', label= 'The proton')\n",
    "axs.plot(xx, ypvypv_sg, 'green', label= \"Smoothed curve\")\n",
    "\n",
    "axs.plot(x, znpv, 'bs', label= 'The new proton')\n",
    "axs.plot(xx, znpvznpv_sg, 'b', label= \"Smoothed curve\")\n",
    "\n",
    "# neutron free state\n",
    "ynv  = np.array([unit.xv13[3], unit.xv13[4], unit.xv13[0], unit.xv13[5], unit.xv13[1],\n",
    "                unit.xv13[3], unit.xv13[2], unit.xv13[4], unit.xv13[5]])  \n",
    "\n",
    "# new neutron free state\n",
    "znnv = np.array([unit.xv02[3], unit.xv02[4], unit.xv02[3], unit.xv02[5],\n",
    "                unit.xv02[4], unit.xv02[0], unit.xv02[4], unit.xv02[1], unit.xv02[2]])  \n",
    "\n",
    "itp3 = PchipInterpolator(x,ynv)\n",
    "itp4 = PchipInterpolator(x,znnv)\n",
    "\n",
    "ynvynv_sg = savgol_filter(itp3(xx), window_size, poly_order)\n",
    "znnvznnv_sg = savgol_filter(itp4(xx), window_size, poly_order)\n",
    "\n",
    "axs.plot(x, ynv, 'ms', label= 'The neutron')\n",
    "axs.plot(xx, ynvynv_sg, 'm', label= \"Smoothed curve\")\n",
    "\n",
    "axs.plot(x, znnv, 'ys', label= 'The new neutron')\n",
    "axs.plot(xx, znnvznnv_sg, 'y', label= \"Smoothed curve\")\n",
    "\n",
    "plt.ylabel('The amount of volume \\n \\n in cbm х Е-45', fontsize=15)\n",
    "plt.xlabel('Shell number', fontsize=15)\n",
    "\n",
    "yticks(fontsize=12)\n",
    "plt.legend(loc='upper left', fontsize=16)\n",
    "grid()         \n",
    "plt.title('THE DISTRIBUTION VOLUME OVER SHELLS \\n Graph#2.\\n', fontsize=17)\n",
    "\n",
    "# The interrelation of frequency, electromagnetic, gravitational \n",
    "# characteristics of a quark \"u\" and \"d\"., 3D graph.\n",
    "\n",
    "fig = plt.figure()\n",
    "ax = Axes3D(fig)\n",
    "X = ([unit5.frequency1[0], unit5.frequency1[1], unit5.frequency1[2]])\n",
    "Y = ([unit4.grav1[0], unit4.grav1[1], unit4.grav1[2]])\n",
    "X,Y = np.meshgrid(X,Y)\n",
    "def f(x,y):\n",
    "    return (sin(x) + cos(y))\n",
    "ax.plot_surface(X,Y,f(X,Y), rstride=1, cstride=1, cmap=cm.coolwarm)\n",
    "ax.view_init(elev=10,azim=155)\n",
    "ax.set_xlabel('\\n \\n \\n The frequency \\n', fontsize = 15)\n",
    "ax.set_ylabel('\\n \\n \\n Gravitational', fontsize = 15)\n",
    "ax.text2D(0.2, 0.95, \n",
    "          '\\nThe interrelation of frequency,\\n'\n",
    "          'gravitational characteristics of \\n'\n",
    "          'a quark \"u\" at v = c.\\n'\n",
    "          'Graph#3.\\n', \n",
    "          transform=ax.transAxes, fontsize = 16)\n",
    "fig = plt.figure()\n",
    "ax = Axes3D(fig)\n",
    "X = ([unit5.frequency0[0], unit5.frequency0[1], unit5.frequency0[2]])\n",
    "Y = ([unit4.grav0[0], unit4.grav0[1], unit4.grav0[2]])\n",
    "X,Y = np.meshgrid(X,Y)\n",
    "def f(x,y):\n",
    "    return (sin(x) + cos(y))\n",
    "ax.plot_surface(X,Y,f(X,Y), rstride=1, cstride=1, cmap=cm.coolwarm)\n",
    "ax.view_init(elev=10,azim=155)\n",
    "ax.set_xlabel('\\n \\n \\n The frequency \\n', fontsize = 15)\n",
    "ax.set_ylabel('\\n \\n \\n Gravitational', fontsize = 15)\n",
    "ax.text2D(0.2, 0.95, \n",
    "          '\\nThe interrelation of frequency,\\n'\n",
    "          'gravitational characteristics of \\n'\n",
    "          'a new quark \"u\" at v = c.\\n'\n",
    "          'Graph#4.\\n', \n",
    "          transform=ax.transAxes, fontsize = 16)\n",
    "fig = plt.figure()\n",
    "ax = Axes3D(fig)\n",
    "X = ([unit3.electro1[0], unit3.electro1[1], unit3.electro1[2]])\n",
    "Y = ([unit4.grav1[0], unit4.grav1[1], unit4.grav1[2]])\n",
    "X,Y = np.meshgrid(X,Y)\n",
    "def f(x,y):\n",
    "    return (sin(x) + cos(y))\n",
    "ax.plot_surface(X,Y,f(X,Y), rstride=1, cstride=1, cmap=cm.coolwarm)\n",
    "ax.view_init(elev=60,azim=70)\n",
    "ax.set_xlabel('\\n \\n \\n Electromagnetic \\n', fontsize = 15)\n",
    "ax.set_ylabel('\\n \\n \\n Gravitational', fontsize = 15)\n",
    "\n",
    "ax.text2D(0.2, 0.95, \n",
    "          '\\nThe interrelation of electromagnetic,\\n'\n",
    "          'gravitational characteristics of \\n'\n",
    "          'a quark \"u\" at v = c.\\n'\n",
    "          'Graph#5.\\n', \n",
    "          transform=ax.transAxes, fontsize = 16)\n",
    "fig = plt.figure()\n",
    "ax = Axes3D(fig)\n",
    "X = ([unit3.electro0[0], unit3.electro0[1], unit3.electro0[2]])\n",
    "Y = ([unit4.grav0[0], unit4.grav0[1], unit4.grav0[2]])\n",
    "X,Y = np.meshgrid(X,Y)\n",
    "def f(x,y):\n",
    "    return (sin(x) + cos(y))\n",
    "ax.plot_surface(X,Y,f(X,Y), rstride=1, cstride=1, cmap=cm.coolwarm)\n",
    "ax.view_init(elev=60,azim=70)\n",
    "ax.set_xlabel('\\n \\n \\n Electromagnetic \\n', fontsize = 15)\n",
    "ax.set_ylabel('\\n \\n \\n Gravitational', fontsize = 15)\n",
    "\n",
    "ax.text2D(0.2, 0.95, \n",
    "          '\\nThe interrelation of electromagnetic,\\n'\n",
    "          'gravitational characteristics of \\n'\n",
    "          'a new quark \"u\" at v = c.\\n'\n",
    "          'Graph#6.\\n', \n",
    "          transform=ax.transAxes, fontsize = 16)\n",
    "fig = plt.figure()\n",
    "ax = Axes3D(fig)\n",
    "X = ([unit5.frequency1[3], unit5.frequency1[4], unit5.frequency1[5]])\n",
    "Y = ([unit4.grav1[3], unit4.grav1[4], unit4.grav1[5]])\n",
    "X,Y = np.meshgrid(X,Y)\n",
    "def f(x,y):\n",
    "    return (sin(x) + cos(y))\n",
    "ax.plot_surface(X,Y,f(X,Y), rstride=1, cstride=1, cmap=cm.coolwarm)\n",
    "ax.view_init(elev=10,azim=100)\n",
    "ax.set_xlabel('\\n \\n \\n The frequency \\n', fontsize = 15)\n",
    "ax.set_ylabel('\\n \\n \\n Gravitational', fontsize = 15)\n",
    "ax.text2D(0.2, 0.95, \n",
    "          '\\nThe interrelation of frequency,\\n'\n",
    "          'gravitational characteristics of \\n'\n",
    "          'a quark \"d\" at v = c.\\n'\n",
    "          'Graph#7.\\n', \n",
    "          transform=ax.transAxes, fontsize = 16)\n",
    "fig = plt.figure()\n",
    "ax = Axes3D(fig)\n",
    "X = ([unit5.frequency0[3], unit5.frequency0[4], unit5.frequency0[5]])\n",
    "Y = ([unit4.grav0[3], unit4.grav0[4], unit4.grav0[5]])\n",
    "X,Y = np.meshgrid(X,Y)\n",
    "def f(x,y):\n",
    "    return (sin(x) + cos(y))\n",
    "ax.plot_surface(X,Y,f(X,Y), rstride=1, cstride=1, cmap=cm.coolwarm)\n",
    "ax.view_init(elev=10,azim=60)\n",
    "ax.set_xlabel('\\n \\n \\n The frequency \\n', fontsize = 15)\n",
    "ax.set_ylabel('\\n \\n \\n Gravitational', fontsize = 15)\n",
    "\n",
    "ax.text2D(0.2, 0.95, \n",
    "          '\\nThe interrelation of frequency,\\n'\n",
    "          'gravitational characteristics of \\n'\n",
    "          'a new quark \"d\" at v = c.\\n'\n",
    "          'Graph#8.\\n', \n",
    "          transform=ax.transAxes, fontsize = 16)\n",
    "fig = plt.figure()\n",
    "ax = Axes3D(fig)\n",
    "X = ([unit3.electro1[3], unit3.electro1[4], unit3.electro1[5]])\n",
    "Y = ([unit4.grav1[3], unit4.grav1[4], unit4.grav1[5]])\n",
    "X,Y = np.meshgrid(X,Y)\n",
    "def f(x,y):\n",
    "    return (sin(x) + cos(y))\n",
    "ax.plot_surface(X,Y,f(X,Y), rstride=1, cstride=1, cmap=cm.coolwarm)\n",
    "ax.view_init(elev=75,azim=65)\n",
    "ax.set_xlabel('\\n \\n \\n Electromagnetic \\n', fontsize = 15)\n",
    "ax.set_ylabel('\\n \\n \\n Gravitational', fontsize = 15)\n",
    "ax.text2D(0.2, 0.95, \n",
    "          '\\nThe interrelation of electromagnetic,\\n'\n",
    "          'gravitational characteristics of \\n'\n",
    "          'a quark \"d\" at v = c.\\n'\n",
    "          'Graph#9.\\n', \n",
    "          transform=ax.transAxes, fontsize = 16)\n",
    "fig = plt.figure()\n",
    "ax = Axes3D(fig)\n",
    "X = ([unit3.electro0[3], unit3.electro0[4], unit3.electro0[5]])\n",
    "Y = ([unit4.grav0[3], unit4.grav0[4], unit4.grav0[5]])\n",
    "X,Y = np.meshgrid(X,Y)\n",
    "def f(x,y):\n",
    "    return (sin(x) + cos(y))\n",
    "ax.plot_surface(X,Y,f(X,Y), rstride=1, cstride=1, cmap=cm.coolwarm)\n",
    "ax.view_init(elev=75,azim=65)\n",
    "ax.set_xlabel('\\n \\n \\n Electromagnetic \\n', fontsize = 15)\n",
    "ax.set_ylabel('\\n \\n \\n Gravitational', fontsize = 15)\n",
    "ax.text2D(0.2, 0.95, \n",
    "          '\\nThe interrelation of electromagnetic,\\n'\n",
    "          'gravitational characteristics of \\n'\n",
    "          'a new quark \"d\" at v = c.\\n'\n",
    "          'Graph#10.\\n', \n",
    "          transform=ax.transAxes, fontsize = 16)\n",
    "plt.show()\n",
    "\n",
    "# The interrelation of frequency, electromagnetic \n",
    "# characteristics of a proton, neutron and their twins 3D graph.\n",
    "fig = plt.figure()\n",
    "ax = Axes3D(fig)\n",
    "X = ([unit10.frequency02[0], unit10.frequency02[1], unit10.frequency02[2],\n",
    "      unit10.frequency02[3], unit10.frequency02[4], unit10.frequency02[5], \n",
    "      unit10.frequency02[6], unit10.frequency02[7], unit10.frequency02[8]])\n",
    "Y = ([unit8.electro01[0], unit8.electro01[1], unit8.electro01[2], \n",
    "      unit8.electro01[3], unit8.electro01[4], unit8.electro01[5], \n",
    "      unit8.electro01[6], unit8.electro01[7], unit8.electro01[8]])\n",
    "X,Y = np.meshgrid(X,Y)\n",
    "def f(x,y):\n",
    "    return (sin(x) + cos(y))\n",
    "ax.plot_surface(X,Y,f(X,Y), rstride=1, cstride=1, cmap=plt.cm.hot)\n",
    "ax.view_init(elev=20,azim=85)\n",
    "ax.set_xlabel('\\n \\n \\n The frequency \\n', fontsize = 15)\n",
    "ax.set_ylabel('\\n \\n \\n Electromagnetic', fontsize = 15)\n",
    "ax.text2D(0.2, 0.95, \n",
    "          'The interrelation of frequency,\\n'\n",
    "          'electromagnetic characteristics\\n'\n",
    "          'of a new neutron at v = c \\n'\n",
    "          'by shells. Graph#11.\\n', \n",
    "          transform=ax.transAxes, fontsize = 16)\n",
    "fig = plt.figure()\n",
    "ax = Axes3D(fig)\n",
    "X = ([unit10.frequency03[0], unit10.frequency03[1], unit10.frequency03[2], \n",
    "      unit10.frequency03[3], unit10.frequency03[4], unit10.frequency03[5], \n",
    "      unit10.frequency03[6], unit10.frequency03[7], unit10.frequency03[8]])\n",
    "Y = ([unit8.electro03[0], unit8.electro03[1], unit8.electro03[2], \n",
    "      unit8.electro03[3], unit8.electro03[4], unit8.electro03[5], \n",
    "      unit8.electro03[6], unit8.electro03[7], unit8.electro03[8]])\n",
    "X,Y = np.meshgrid(X,Y)\n",
    "def f(x,y):\n",
    "    return (sin(x) + cos(y))\n",
    "ax.plot_surface(X,Y,f(X,Y), rstride=1, cstride=1, cmap=plt.cm.hot)\n",
    "ax.view_init(elev=20,azim=85)\n",
    "ax.set_xlabel('\\n \\n \\n The frequency \\n', fontsize = 15)\n",
    "ax.set_ylabel('\\n \\n \\n Electromagnetic', fontsize = 15)\n",
    "ax.text2D(0.2, 0.95, \n",
    "          'The interrelation of frequency,\\n'\n",
    "          'electromagnetic characteristics\\n'\n",
    "          'of a neutron at v = c \\n'\n",
    "          'by shells. Graph#12.\\n', \n",
    "          transform=ax.transAxes, fontsize = 16)\n",
    "fig = plt.figure()\n",
    "ax = Axes3D(fig)\n",
    "X = ([unit10.frequency05[0], unit10.frequency05[1], unit10.frequency05[2], \n",
    "      unit10.frequency05[3], unit10.frequency05[4], unit10.frequency05[5], \n",
    "      unit10.frequency05[6], unit10.frequency05[7], unit10.frequency05[8]])\n",
    "Y = ([unit8.electro04[0], unit8.electro04[1], unit8.electro04[2], \n",
    "      unit8.electro04[3], unit8.electro04[4], unit8.electro04[5], \n",
    "      unit8.electro04[6], unit8.electro04[7], unit8.electro04[8]])\n",
    "X,Y = np.meshgrid(X,Y)\n",
    "def f(x,y):\n",
    "    return (sin(x) + cos(y))\n",
    "ax.plot_surface(X,Y,f(X,Y), rstride=1, cstride=1, cmap=plt.cm.hot)\n",
    "ax.view_init(elev=20,azim=85)\n",
    "ax.set_xlabel('\\n \\n \\n The frequency \\n', fontsize = 15)\n",
    "ax.set_ylabel('\\n \\n \\n Electromagnetic', fontsize = 15)\n",
    "ax.text2D(0.2, 0.95, \n",
    "          'The interrelation of frequency,\\n'\n",
    "          'electromagnetic characteristics\\n'\n",
    "          'of a proton at v = c \\n'\n",
    "          'by shells. Graph#13.\\n', \n",
    "          transform=ax.transAxes, fontsize = 16)\n",
    "fig = plt.figure()\n",
    "ax = Axes3D(fig)\n",
    "X = ([unit10.frequency04[0], unit10.frequency04[1], unit10.frequency04[2], \n",
    "      unit10.frequency04[3], unit10.frequency04[4], unit10.frequency04[5], \n",
    "      unit10.frequency04[6], unit10.frequency04[7], unit10.frequency04[8]])\n",
    "Y = ([unit8.electro02[0], unit8.electro02[1], unit8.electro02[2], \n",
    "      unit8.electro02[3], unit8.electro02[4], unit8.electro02[5], \n",
    "      unit8.electro02[6], unit8.electro02[7], unit8.electro02[8]])\n",
    "X,Y = np.meshgrid(X,Y)\n",
    "def f(x,y):\n",
    "    return (sin(x) + cos(y))\n",
    "ax.plot_surface(X,Y,f(X,Y), rstride=1, cstride=1, cmap=plt.cm.hot)\n",
    "ax.view_init(elev=20,azim=85)\n",
    "ax.set_xlabel('\\n \\n \\n The frequency \\n', fontsize = 15)\n",
    "ax.set_ylabel('\\n \\n \\n Electromagnetic', fontsize = 15)\n",
    "ax.text2D(0.2, 0.95, \n",
    "          'The interrelation of frequency,\\n'\n",
    "          'electromagnetic characteristics\\n'\n",
    "          'of a new proton at v = c \\n'\n",
    "          'by shells. Graph#14.\\n', \n",
    "          transform=ax.transAxes, fontsize = 16)\n",
    "plt.show()\n",
    "\n",
    "# The interrelation of frequency, electromagnetic, wavelength \n",
    "# characteristics of a proton, 3D graph.\n",
    "fig = plt.figure(figsize=plt.figaspect(0.3))\n",
    "ax = fig.add_subplot(1, 2, 1, projection='3d')\n",
    "# proton\n",
    "Xpu = ([unit10.frequency05[0], unit10.frequency05[1], \n",
    "        unit10.frequency05[2], unit10.frequency05[3], unit10.frequency05[4], \n",
    "        unit10.frequency05[5], unit10.frequency05[6], unit10.frequency05[7], \n",
    "        unit10.frequency05[8]])\n",
    "Ypu = ([unit8.electro15[0], unit8.electro15[1], \n",
    "        unit8.electro15[2], unit8.electro15[3], unit8.electro15[4], \n",
    "        unit8.electro15[5], unit8.electro15[6], unit8.electro15[7], \n",
    "        unit8.electro15[8]])\n",
    "Zpu = ([unit7.wave31[0], unit7.wave31[1], unit7.wave31[2], \n",
    "        unit7.wave31[3], unit7.wave31[4], unit7.wave31[5], \n",
    "        unit7.wave31[6], unit7.wave31[7], unit7.wave31[8]])\n",
    "\n",
    "ax.plot(Xpu,Ypu,Zpu) \n",
    "\n",
    "ax.set_xlabel('\\n \\n \\n The frequency \\n', fontsize = 15)\n",
    "ax.set_zlabel('\\n \\n \\n Electromagnetic', fontsize = 15)\n",
    "ax.set_ylabel('\\n \\n \\n Wavelength', fontsize = 15)\n",
    "\n",
    "ax.text2D(0.2, 0.95, \n",
    "          'The interrelation of frequency,\\n'\n",
    "          'electromagnetic, wavelength\\n'\n",
    "          'characteristics of a proton\\n'\n",
    "          'at v = c by shells. Graph#15.\\n', \n",
    "          transform=ax.transAxes, fontsize = 16)\n",
    "\n",
    "# The interrelation of frequency, electromagnetic, wavelength \n",
    "# characteristics of a new proton, 3D graph.\n",
    "\n",
    "ax = fig.add_subplot(1, 2, 2, projection='3d')\n",
    "\n",
    "Xku = ([unit10.frequency04[0], unit10.frequency04[1], \n",
    "        unit10.frequency04[2], unit10.frequency04[3], unit10.frequency04[4], \n",
    "        unit10.frequency04[5], unit10.frequency04[6], unit10.frequency04[7], \n",
    "        unit10.frequency04[8]])\n",
    "Yku = ([unit8.electro14[0], unit8.electro14[1], \n",
    "        unit8.electro14[2], unit8.electro14[3], unit8.electro14[4], \n",
    "        unit8.electro14[5], unit8.electro14[6], unit8.electro14[7], \n",
    "        unit8.electro14[8]])\n",
    "Zku = ([unit7.wave21[0], unit7.wave21[1], unit7.wave21[2], \n",
    "        unit7.wave21[3], unit7.wave21[4], unit7.wave21[5], \n",
    "        unit7.wave21[6], unit7.wave21[7], unit7.wave21[8]])\n",
    "\n",
    "ax.plot(Xku,Yku,Zku) \n",
    "\n",
    "ax.set_xlabel('\\n \\n \\n The frequency \\n', fontsize = 15)\n",
    "ax.set_zlabel('\\n \\n \\n Electromagnetic', fontsize = 15)\n",
    "ax.set_ylabel('\\n \\n \\n Wavelength', fontsize = 15)\n",
    "\n",
    "ax.text2D(0.2, 0.95, \n",
    "          'The interrelation of frequency,\\n'\n",
    "          'electromagnetic, wavelength\\n'\n",
    "          'characteristics of a new proton \\n'\n",
    "          'at v = c by shells. Graph#16.\\n', \n",
    "          transform=ax.transAxes, fontsize = 16)\n",
    "\n",
    "# The interrelation of frequency, electromagnetic, wavelength \n",
    "# characteristics of a neutron, 3D graph.\n",
    "fig = plt.figure(figsize=plt.figaspect(0.3))\n",
    "ax = fig.add_subplot(1, 2, 1, projection='3d')\n",
    "# neutron\n",
    "Xpu = ([unit10.frequency03[0], unit10.frequency03[1], \n",
    "        unit10.frequency03[2], unit10.frequency03[3], unit10.frequency03[4], \n",
    "        unit10.frequency03[5], unit10.frequency03[6], unit10.frequency03[7], \n",
    "        unit10.frequency03[8]])\n",
    "Ypu = ([unit8.electro03[0], unit8.electro03[1], \n",
    "        unit8.electro03[2], unit8.electro03[3], unit8.electro03[4], \n",
    "        unit8.electro03[5], unit8.electro03[6], unit8.electro03[7], \n",
    "        unit8.electro03[8]])\n",
    "Zpu = ([unit7.wave11[0], unit7.wave11[1], unit7.wave11[2], \n",
    "        unit7.wave11[3], unit7.wave11[4], unit7.wave11[5], \n",
    "        unit7.wave11[6], unit7.wave11[7], unit7.wave11[8]])\n",
    "\n",
    "ax.plot(Xpu,Ypu,Zpu) \n",
    "\n",
    "ax.set_xlabel('\\n \\n \\n The frequency \\n', fontsize = 15)\n",
    "ax.set_zlabel('\\n \\n \\n Electromagnetic', fontsize = 15)\n",
    "ax.set_ylabel('\\n \\n \\n Wavelength', fontsize = 15)\n",
    "\n",
    "ax.text2D(0.2, 0.95, \n",
    "          'The interrelation of frequency,\\n'\n",
    "          'electromagnetic, wavelength\\n'\n",
    "          'characteristics of a neutron\\n'\n",
    "          'at v = c by shells. Graph#17.\\n', \n",
    "          transform=ax.transAxes, fontsize = 16)\n",
    "\n",
    "# The interrelation of frequency, electromagnetic, wavelength \n",
    "# characteristics of a new neutron, 3D graph.\n",
    "\n",
    "ax = fig.add_subplot(1, 2, 2, projection='3d')\n",
    "\n",
    "Xku = ([unit10.frequency02[0], unit10.frequency02[1], \n",
    "        unit10.frequency02[2], unit10.frequency02[3], unit10.frequency02[4], \n",
    "        unit10.frequency02[5], unit10.frequency02[6], unit10.frequency02[7], \n",
    "        unit10.frequency02[8]])\n",
    "Yku = ([unit8.electro01[0], unit8.electro01[1], \n",
    "        unit8.electro01[2], unit8.electro01[3], unit8.electro01[4], \n",
    "        unit8.electro01[5], unit8.electro01[6], unit8.electro01[7], \n",
    "        unit8.electro01[8]])\n",
    "Zku = ([unit7.wave01[0], unit7.wave01[1], unit7.wave01[2], \n",
    "        unit7.wave01[3], unit7.wave01[4], unit7.wave01[5], \n",
    "        unit7.wave01[6], unit7.wave01[7], unit7.wave01[8]])\n",
    "\n",
    "ax.plot(Xku,Yku,Zku) \n",
    "\n",
    "ax.set_xlabel('\\n \\n \\n The frequency \\n', fontsize = 15)\n",
    "ax.set_zlabel('\\n \\n \\n Electromagnetic', fontsize = 15)\n",
    "ax.set_ylabel('\\n \\n \\n Wavelength', fontsize = 15)\n",
    "\n",
    "ax.text2D(0.2, 0.95, \n",
    "          'The interrelation of frequency,\\n'\n",
    "          'electromagnetic, wavelength\\n'\n",
    "          'characteristics of a new neutron \\n'\n",
    "          'at v = c by shells. Graph#18.\\n', \n",
    "          transform=ax.transAxes, fontsize = 16)\n",
    "\n",
    "# neutron\n",
    "# The more N, then to generate a dense grid.\n",
    "N = 20\n",
    "# Random data is generated in class 11.\n",
    "volume = np.random.rand(N, N, N)\n",
    "# The x, y, and z coordinate arrays taken from class 11.  \n",
    "x = unit11.frequenn\n",
    "y = unit11.wavelengthn\n",
    "z = unit11.v\n",
    "x, y, z = np.broadcast_arrays(x, y, z)\n",
    "# The volumetric data turn into an RGB array.\n",
    "c = np.tile(volume.ravel()[:, None], [1, 3])\n",
    "fig = plt.figure(figsize=(12,12))\n",
    "ax = fig.gca(projection='3d')\n",
    "ax.scatter(x.ravel(),\n",
    "           y.ravel(),\n",
    "           z.ravel(),\n",
    "           c=c)\n",
    "ax.set_xlabel('\\n \\n \\n Frequency \\n', fontsize = 15)\n",
    "ax.set_ylabel('\\n \\n \\n Wavelength\\n', fontsize = 15)\n",
    "ax.set_zlabel('\\n \\n \\n Velocity\\n', fontsize = 15)\n",
    "ax.text2D(0.2, 0.95, \n",
    "          '\\nThe interrelation of frequency,wavelength and\\n'\n",
    "          'velocity of a neutron. Graph#19.', \n",
    "          transform=ax.transAxes, fontsize = 16)\n",
    "fig = plt.figure()\n",
    "# new neutron\n",
    "# The more N, then to generate a dense grid.\n",
    "N = 20\n",
    "# Random data is generated in class 11.\n",
    "volume = np.random.rand(N, N, N)\n",
    "# The x, y, and z coordinate arrays taken from class 11.  \n",
    "y = unit11.frequennn\n",
    "x = unit11.wavelengthnn\n",
    "z = unit11.v\n",
    "x, y, z = np.broadcast_arrays(x, y, z)\n",
    "# The volumetric data turn into an RGB array.\n",
    "c = np.tile(volume.ravel()[:, None], [1, 3])\n",
    "fig = plt.figure(figsize=(12,12))\n",
    "ax = fig.gca(projection='3d')\n",
    "ax.scatter(x.ravel(),\n",
    "           y.ravel(),\n",
    "           z.ravel(),\n",
    "           c=c)\n",
    "ax.set_xlabel('\\n \\n \\n Wavelength \\n', fontsize = 15)\n",
    "ax.set_ylabel('\\n \\n \\n Frequency\\n', fontsize = 15)\n",
    "ax.set_zlabel('\\n \\n \\n Velocity\\n', fontsize = 15)\n",
    "ax.text2D(0.2, 0.95, \n",
    "          '\\nThe interrelation of frequency,wavelength and\\n'\n",
    "          'velocity of a new neutron. Graph#20.', \n",
    "          transform=ax.transAxes, fontsize = 16)\n",
    "fig = plt.figure()\n",
    "# proton\n",
    "# The more N, then to generate a dense grid.\n",
    "N = 20\n",
    "# Random data is generated in class 11.\n",
    "volume = np.random.rand(N, N, N)\n",
    "# The x, y, and z coordinate arrays taken from class 11.  \n",
    "z = unit11.frequenp\n",
    "y = unit11.wavelengthp\n",
    "x = unit11.v\n",
    "x, y, z = np.broadcast_arrays(x, y, z)\n",
    "# The volumetric data turn into an RGB array.\n",
    "c = np.tile(volume.ravel()[:, None], [1, 3])\n",
    "fig = plt.figure(figsize=(12,12))\n",
    "ax = fig.gca(projection='3d')\n",
    "ax.scatter(x.ravel(),\n",
    "           y.ravel(),\n",
    "           z.ravel(),\n",
    "           c=c)\n",
    "ax.set_xlabel('\\n \\n \\n Velocity  \\n', fontsize = 15)\n",
    "ax.set_ylabel('\\n \\n \\n Wavelength\\n', fontsize = 15)\n",
    "ax.set_zlabel('\\n \\n \\n Frequency\\n', fontsize = 15)\n",
    "ax.text2D(0.2, 0.95, \n",
    "          '\\nThe interrelation of frequency,wavelength and\\n'\n",
    "          'velocity of a proton. Graph#21.', \n",
    "          transform=ax.transAxes, fontsize = 16)\n",
    "fig = plt.figure() \n",
    "# new proton\n",
    "# The more N, then to generate a dense grid.\n",
    "N = 20\n",
    "# Random data is generated in class 11.\n",
    "volume = np.random.rand(N, N, N)\n",
    "# The x, y, and z coordinate arrays taken from class 11.  \n",
    "x = unit11.frequennp\n",
    "z = unit11.wavelengthnp\n",
    "y = unit11.v\n",
    "x, y, z = np.broadcast_arrays(x, y, z)\n",
    "# The volumetric data turn into an RGB array.\n",
    "c = np.tile(volume.ravel()[:, None], [1, 3])\n",
    "fig = plt.figure(figsize=(12,12))\n",
    "ax = fig.gca(projection='3d')\n",
    "ax.scatter(x.ravel(),\n",
    "           y.ravel(),\n",
    "           z.ravel(),\n",
    "           c=c)\n",
    "ax.set_xlabel('\\n \\n \\n Frequency \\n', fontsize = 15)\n",
    "ax.set_ylabel('\\n \\n \\n Velocity \\n', fontsize = 15)\n",
    "ax.set_zlabel('\\n \\n \\n Wavelength \\n', fontsize = 15)\n",
    "ax.text2D(0.2, 0.95, \n",
    "          '\\nThe interrelation of frequency,wavelength and\\n'\n",
    "          'velocity of a new proton. Graph#22.', \n",
    "          transform=ax.transAxes, fontsize = 16)\n",
    "fig = plt.figure() \n",
    "\n",
    "# Root mean square difference in electric charge between\n",
    "# neutron and new neutron.\n",
    "# This value is between the dashed lines in Graph 1.\n",
    "delta_neutronq = (sum(znnznn_fit) - sum(ynyn_fit))/len(ynyn_fit)\n",
    "print('Root mean square difference in electric charge \\n'\n",
    "      'between neutron and new neutron:', delta_neutronq)\n",
    "# Generating 8000 gravity values.\n",
    "for j in range(8):\n",
    "    grav = np.random.uniform(grav01[j], grav01[j+1], size=(1, 8000))\n",
    "# Generating 8000 electromagnetic values.\n",
    "for j in range(8):\n",
    "    electro = np.random.uniform(electro01[j], electro01[j+1], size=(1, 8000))\n",
    "\n",
    "# The interrelation of frequency, gravity, and velocity of a new proton.\n",
    "# The more N, then to generate a dense grid.\n",
    "N = 20\n",
    "volume = np.random.rand(N, N, N)\n",
    "x = unit11.frequennp\n",
    "z = grav\n",
    "y = unit11.v\n",
    "x, y, z = np.broadcast_arrays(x, y, z)\n",
    "# The volumetric data turn into an RGB array.\n",
    "c = np.tile(volume.ravel()[:, None], [1, 3])\n",
    "fig = plt.figure(figsize=(12,12))\n",
    "ax = fig.gca(projection='3d')\n",
    "ax.scatter(x.ravel(),\n",
    "           y.ravel(),\n",
    "           z.ravel(),\n",
    "           c=c)\n",
    "ax.set_xlabel('\\n \\n \\n Frequency \\n', fontsize = 15)\n",
    "ax.set_ylabel('\\n \\n \\n Velocity \\n', fontsize = 15)\n",
    "ax.set_zlabel('\\n \\n \\n Gravity \\n', fontsize = 15)\n",
    "ax.text2D(0.2, 0.95, \n",
    "          '\\nThe interrelation of frequency, gravity and\\n'\n",
    "          'velocity of a new proton. Graph#23.', \n",
    "          transform=ax.transAxes, fontsize = 16)\n",
    "fig = plt.figure() \n",
    "\n",
    "# The interrelation of electromagnetic wave, gravity, and velocity of a new proton.\n",
    "# The more N, then to generate a dense grid.\n",
    "N = 20\n",
    "volume = np.random.rand(N, N, N)\n",
    "z = electro\n",
    "y = grav\n",
    "x = unit11.v\n",
    "x, y, z = np.broadcast_arrays(x, y, z)\n",
    "# The volumetric data turn into an RGB array.\n",
    "c = np.tile(volume.ravel()[:, None], [1, 3])\n",
    "fig = plt.figure(figsize=(12,12))\n",
    "ax = fig.gca(projection='3d')\n",
    "ax.scatter(x.ravel(),\n",
    "           y.ravel(),\n",
    "           z.ravel(),\n",
    "           c=c)\n",
    "ax.set_xlabel('\\n \\n \\n Electromagnetic wave \\n', fontsize = 15)\n",
    "ax.set_ylabel('\\n \\n \\n Gravity \\n', fontsize = 15)\n",
    "ax.set_zlabel('\\n \\n \\n Velocity \\n', fontsize = 15)\n",
    "ax.text2D(0.2, 0.95, \n",
    "          '\\nThe interrelation of electromagnetic wave, gravity and\\n'\n",
    "          'velocity of a new proton. Graph#24.', \n",
    "          transform=ax.transAxes, fontsize = 16)\n",
    "fig = plt.figure() \n",
    "\n",
    "# The interrelation of electromagnetic wave, gravity, and frequency of a new proton.\n",
    "N = 20\n",
    "volume = np.random.rand(N, N, N)\n",
    "z = electro\n",
    "y = grav\n",
    "x = unit11.frequennp\n",
    "x, y, z = np.broadcast_arrays(x, y, z)\n",
    "# The volumetric data turn into an RGB array.\n",
    "c = np.tile(volume.ravel()[:, None], [1, 3])\n",
    "fig = plt.figure(figsize=(12,12))\n",
    "ax = fig.gca(projection='3d')\n",
    "ax.scatter(x.ravel(),\n",
    "           y.ravel(),\n",
    "           z.ravel(),\n",
    "           c=c)\n",
    "ax.set_xlabel('\\n \\n \\n Frequency \\n', fontsize = 15)\n",
    "ax.set_ylabel('\\n \\n \\n Gravity \\n', fontsize = 15)\n",
    "ax.set_zlabel('\\n \\n \\n Electromagnetic wave \\n', fontsize = 15)\n",
    "ax.text2D(0.2, 0.95, \n",
    "          '\\nThe interrelation of electromagnetic wave, gravity and\\n'\n",
    "          'frequency of a new proton. Graph#25.', \n",
    "          transform=ax.transAxes, fontsize = 16)\n",
    "fig = plt.figure() \n",
    "print('\\n Initial conditions. Table 1.\\n')\n",
    "print(table1)\n",
    "print('\\nData obtained during the implementation of the algorithm. Table 2.\\n')\n",
    "print(table2)        \n",
    "print('\\nValues of electric charge, mass, volume by shells for the new proton.\\n'\n",
    "     'Table 3.')\n",
    "print(table3)\n",
    "print('\\nValues of electric charge, mass, volume by shells for the proton.\\n'\n",
    "     'Table 4.')\n",
    "print(table4)\n",
    "print('\\nValues of electric charge, mass, volume by shells for the new neutron.\\n'\n",
    "     'Table 5.')\n",
    "print(table5)\n",
    "print('\\nValues of electric charge, mass, volume by shells for the neutron.\\n'\n",
    "     'Table 6.')\n",
    "print(table6)\n",
    "print('\\n Mass, electric charge and volume of the \\n' \n",
    "      'smallest particle carrying electric charge.\\n'\n",
    "      'Table 7.')\n",
    "print(table7)"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.6"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
